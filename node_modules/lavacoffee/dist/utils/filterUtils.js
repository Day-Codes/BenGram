"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FilterUtils_1, EqualizerUtils_1, KaraokeUtils_1, TimescaleUtils_1, TremoloUtils_1, VibratoUtils_1, RotationUtils_1, DistortionUtils_1, ChannelMixUtils_1, LowPassUtils_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LowPassUtils = exports.ChannelMixUtils = exports.DistortionUtils = exports.RotationUtils = exports.VibratoUtils = exports.TremoloUtils = exports.TimescaleUtils = exports.KaraokeUtils = exports.EqualizerUtils = exports.FilterUtils = void 0;
/* eslint-disable @typescript-eslint/no-use-before-define */
/* eslint-disable func-names */
/* eslint-disable prefer-arrow-callback */
require("../structures");
const validators_1 = require("./decorators/validators");
const constructs_1 = require("./decorators/constructs");
/** Filters builder utility */
let FilterUtils = FilterUtils_1 = class FilterUtils {
    constructor(filters) {
        this.volume = filters.volume;
        this.equalizers = new EqualizerUtils(filters.equalizer);
        this.karaoke = new KaraokeUtils(filters.karaoke);
        this.timescale = new TimescaleUtils(filters.timescale);
        this.tremolo = new TremoloUtils(filters.tremolo);
        this.vibrato = new VibratoUtils(filters.vibrato);
        this.rotation = new RotationUtils(filters.rotation);
        this.distortion = new DistortionUtils(filters.distortion);
        this.channelMix = new ChannelMixUtils(filters.channelMix);
        this.lowPass = new LowPassUtils(filters.lowPass);
    }
    /** Set the filter volume */
    setVolume(volume) {
        this.volume = volume;
        return this;
    }
    /** Build the filters */
    build() {
        const filters = {};
        if (this.volume && !isNaN(this.volume) && this.volume !== 1)
            filters.volume = this.volume;
        if (this.equalizers.enabled)
            filters.equalizer = this.equalizers.build();
        if (this.karaoke.enabled)
            filters.karaoke = this.karaoke.build();
        if (this.timescale.enabled)
            filters.timescale = this.timescale.build();
        if (this.tremolo.enabled)
            filters.tremolo = this.tremolo.build();
        if (this.vibrato.enabled)
            filters.vibrato = this.vibrato.build();
        if (this.rotation.enabled)
            filters.rotation = this.rotation.build();
        if (this.distortion.enabled)
            filters.distortion = this.distortion.build();
        if (this.channelMix.enabled)
            filters.channelMix = this.channelMix.build();
        if (this.lowPass.enabled)
            filters.lowPass = this.lowPass.build();
        return filters;
    }
};
__decorate([
    validators_1.check(function (method, volume) {
        if (typeof volume !== "number" || isNaN(volume))
            throw new TypeError("Parameter 'volume' must be present and be a number");
        if (volume < 0)
            throw new TypeError("Parameter 'volume' must be more or equal than 0");
        return method(volume);
    })
], FilterUtils.prototype, "setVolume", null);
FilterUtils = FilterUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        const filters = args[0] ?? {};
        if (typeof filters !== "object" ||
            filters === null)
            throw new TypeError("FilterUtils parameter 'filters' must be an object");
        return new target(filters);
    })
], FilterUtils);
exports.FilterUtils = FilterUtils;
/** Equalizer filter builder utility */
let EqualizerUtils = EqualizerUtils_1 = class EqualizerUtils {
    constructor(equalizers) {
        this.enabled = false;
        this.equalizers = new Map();
        if (Array.isArray(equalizers)) {
            for (const equalizer of equalizers) {
                this.equalizers.set(equalizer.band, equalizer);
            }
        }
    }
    /** Set a band equalizer, band must be between 0 to 14, gain must be between -0.25 to 1 */
    setBand(band, gain) {
        this.equalizers.set(band, { band, gain });
        if (gain !== 0)
            this.enabled = true;
        else if (!this.equalizers.size ||
            [...this.equalizers.values()].every(eq => eq.gain === 0))
            this.enabled = false;
        return this;
    }
    /** Clear the equalizers filter */
    clear() {
        this.equalizers.clear();
        this.enabled = false;
        return this;
    }
    /** Build the equalizers */
    build() {
        const equalizers = [...this.equalizers.values()].filter(eq => eq.gain !== 0);
        // Pretty equalizers
        equalizers.sort((left, right) => left.band - right.band);
        return equalizers;
    }
};
__decorate([
    validators_1.check(function (method, band, gain) {
        if (typeof band !== "number" || isNaN(band))
            throw new TypeError("Parameter 'band' must be present be a number");
        if (typeof gain !== "number" || isNaN(gain))
            throw new TypeError("Parameter 'gain' must be present and be a number");
        if (band < 0 || band > 14)
            throw new TypeError("Parameter 'band' must be between 0 to 14");
        if (gain < -0.25 || gain > 1)
            throw new TypeError("Parameter 'gain' must be between -0.25 to 1");
        return method(band, gain);
    })
], EqualizerUtils.prototype, "setBand", null);
EqualizerUtils = EqualizerUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        const equalizers = args[0];
        let enabled = false;
        if (Array.isArray(equalizers) &&
            equalizers.length &&
            equalizers.some(eq => eq.gain !== 0))
            enabled = true;
        const instance = new target(equalizers);
        instance.enabled = enabled;
        return instance;
    })
], EqualizerUtils);
exports.EqualizerUtils = EqualizerUtils;
/** Karaoke filter builder utility */
let KaraokeUtils = KaraokeUtils_1 = class KaraokeUtils {
    constructor(karaoke) {
        this.enabled = false;
        this.karaoke = karaoke;
    }
    /** Set the level */
    setLevel(level) {
        this.karaoke.level = level;
        this.enabled = true;
        return this;
    }
    /** Set the mono level */
    setMonoLevel(monoLevel) {
        this.karaoke.monoLevel = monoLevel;
        this.enabled = true;
        return this;
    }
    /** Set the filter band */
    setFilterBand(filterBand) {
        this.karaoke.filterBand = filterBand;
        this.enabled = true;
        return this;
    }
    /** Set the filter width */
    setFilterWidth(filterWidth) {
        this.karaoke.filterWidth = filterWidth;
        this.enabled = true;
        return this;
    }
    /** Disable the karaoke filter */
    disable() {
        this.enabled = false;
        return this;
    }
    /** Build the karaoke filter */
    build() {
        return this.karaoke;
    }
};
__decorate([
    validators_1.check(function (method, level) {
        if (typeof level !== "number" || isNaN(level))
            throw new TypeError("Parameter 'level' must be present and be a number");
        return method(level);
    })
], KaraokeUtils.prototype, "setLevel", null);
__decorate([
    validators_1.check(function (method, monoLevel) {
        if (typeof monoLevel !== "number" || isNaN(monoLevel))
            throw new TypeError("Parameter 'monoLevel' must be present and be a number");
        return method(monoLevel);
    })
], KaraokeUtils.prototype, "setMonoLevel", null);
__decorate([
    validators_1.check(function (method, filterBand) {
        if (typeof filterBand !== "number" || isNaN(filterBand))
            throw new TypeError("Parameter 'filterband' must be present and be a number");
        return method(filterBand);
    })
], KaraokeUtils.prototype, "setFilterBand", null);
__decorate([
    validators_1.check(function (method, filterWidth) {
        if (typeof filterWidth !== "number" || isNaN(filterWidth))
            throw new TypeError("Parameter 'filterWidth' must be present and be a number");
        return method(filterWidth);
    })
], KaraokeUtils.prototype, "setFilterWidth", null);
KaraokeUtils = KaraokeUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        let karaoke = args[0];
        let enabled = false;
        if (typeof karaoke === "object" &&
            karaoke !== null)
            enabled = true;
        else
            karaoke = { level: 1, monoLevel: 1, filterBand: 220, filterWidth: 100 };
        const instance = new target(karaoke);
        instance.enabled = enabled;
        return instance;
    })
], KaraokeUtils);
exports.KaraokeUtils = KaraokeUtils;
/** Timescale filter builder utility */
let TimescaleUtils = TimescaleUtils_1 = class TimescaleUtils {
    constructor(timescale) {
        this.enabled = false;
        this.timescale = timescale;
    }
    /** Set the speed, must be more than 0 */
    setSpeed(speed) {
        this.timescale.speed = speed;
        if (speed !== 1)
            this.enabled = true;
        else if (this.timescale.speed === 1 &&
            this.timescale.pitch === 1 &&
            this.timescale.rate === 1)
            this.enabled = false;
        return this;
    }
    /** Set the pitch, must be more than 0 */
    setPitch(pitch) {
        this.timescale.pitch = pitch;
        if (pitch !== 1)
            this.enabled = true;
        else if (this.timescale.speed === 1 &&
            this.timescale.pitch === 1 &&
            this.timescale.rate === 1)
            this.enabled = false;
        return this;
    }
    /** Set the rate, must be more than 0 */
    setRate(rate) {
        this.timescale.rate = rate;
        if (rate !== 1)
            this.enabled = true;
        else if (this.timescale.speed === 1 &&
            this.timescale.pitch === 1 &&
            this.timescale.rate === 1)
            this.enabled = false;
        return this;
    }
    /** Build the timescale filter */
    build() {
        return this.timescale;
    }
};
__decorate([
    validators_1.check(function (method, speed) {
        if (typeof speed !== "number" || isNaN(speed))
            throw new TypeError("Parameter 'speed' must be present and be a number");
        if (speed <= 0)
            throw new TypeError("Parameter 'speed' must be more than 0");
        return method(speed);
    })
], TimescaleUtils.prototype, "setSpeed", null);
__decorate([
    validators_1.check(function (method, pitch) {
        if (typeof pitch !== "number" || isNaN(pitch))
            throw new TypeError("Parameter 'pitch' must be present and be a number");
        if (pitch <= 0)
            throw new TypeError("Parameter 'pitch' must be more than 0");
        return method(pitch);
    })
], TimescaleUtils.prototype, "setPitch", null);
__decorate([
    validators_1.check(function (method, rate) {
        if (typeof rate !== "number" || isNaN(rate))
            throw new TypeError("Parameter 'rate' must be present and be a number");
        if (rate <= 0)
            throw new TypeError("Parameter 'rate' must be more than 0");
        return method(rate);
    })
], TimescaleUtils.prototype, "setRate", null);
TimescaleUtils = TimescaleUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        let timescale = args[0];
        let enabled = false;
        if (typeof timescale === "object" &&
            timescale !== null &&
            (timescale.speed !== 1 ||
                timescale.pitch !== 1 ||
                timescale.rate !== 1))
            enabled = true;
        else
            timescale = { speed: 1, pitch: 1, rate: 1 };
        const instance = new target(timescale);
        instance.enabled = enabled;
        return instance;
    })
], TimescaleUtils);
exports.TimescaleUtils = TimescaleUtils;
/** Tremolo filter builder utility */
let TremoloUtils = TremoloUtils_1 = class TremoloUtils {
    constructor(tremolo) {
        this.enabled = false;
        this.tremolo = tremolo;
    }
    /** Set the frequency, must be more than 0 */
    setFrequency(frequency) {
        this.tremolo.frequency = frequency;
        return this;
    }
    /** Set the depth, must be between 0 to 1 */
    setDepth(depth) {
        this.tremolo.depth = depth;
        this.enabled = depth !== 0;
        return this;
    }
    /** Build the tremolo filter */
    build() {
        return this.tremolo;
    }
};
__decorate([
    validators_1.check(function (method, frequency) {
        if (typeof frequency !== "number" || isNaN(frequency))
            throw new TypeError("Parameter 'frequency' must be present and be a number");
        if (frequency <= 0)
            throw new TypeError("Parameter 'frequency' must be more than 0");
        return method(frequency);
    })
], TremoloUtils.prototype, "setFrequency", null);
__decorate([
    validators_1.check(function (method, depth) {
        if (typeof depth !== "number" || isNaN(depth))
            throw new TypeError("Parameter 'depth' must be present and be a number");
        if (depth < 0 || depth > 1)
            throw new TypeError("Parameter 'depth' must be between 0 to 1");
        return method(depth);
    })
], TremoloUtils.prototype, "setDepth", null);
TremoloUtils = TremoloUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        let tremolo = args[0];
        let enabled = false;
        if (typeof tremolo === "object" &&
            tremolo !== null &&
            tremolo.depth !== 0)
            enabled = true;
        else
            tremolo = { frequency: 2, depth: 0.5 };
        const instance = new target(tremolo);
        instance.enabled = enabled;
        return instance;
    })
], TremoloUtils);
exports.TremoloUtils = TremoloUtils;
/** Vibrato filter builder utility */
let VibratoUtils = VibratoUtils_1 = class VibratoUtils {
    constructor(vibrato) {
        this.enabled = false;
        this.vibrato = vibrato;
    }
    /** Set the frequency, must be between 0 and 15 */
    setFrequency(frequency) {
        this.vibrato.frequency = frequency;
        return this;
    }
    /** Set the depth, must be between 0 to 1 */
    setDepth(depth) {
        this.vibrato.depth = depth;
        this.enabled = depth !== 0;
        return this;
    }
    /** Build the vibrato filter */
    build() {
        return this.vibrato;
    }
};
__decorate([
    validators_1.check(function (method, frequency) {
        if (typeof frequency !== "number" || isNaN(frequency))
            throw new TypeError("Parameter 'frequency' must be present and be a number");
        if (frequency <= 0 ||
            frequency > 14)
            throw new TypeError("Parameter 'frequency' must be between 0 and 15");
        return method(frequency);
    })
], VibratoUtils.prototype, "setFrequency", null);
__decorate([
    validators_1.check(function (method, depth) {
        if (typeof depth !== "number" || isNaN(depth))
            throw new TypeError("Parameter 'depth' must be present and be a number");
        if (depth < 0 || depth > 1)
            throw new TypeError("Parameter 'depth' must be between 0 to 1");
        return method(depth);
    })
], VibratoUtils.prototype, "setDepth", null);
VibratoUtils = VibratoUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        let vibrato = args[0];
        let enabled = false;
        if (typeof vibrato === "object" &&
            vibrato !== null &&
            vibrato.depth !== 0)
            enabled = true;
        else
            vibrato = { frequency: 2, depth: 0.5 };
        const instance = new target(vibrato);
        instance.enabled = enabled;
        return instance;
    })
], VibratoUtils);
exports.VibratoUtils = VibratoUtils;
/** Rotation filter builder utility */
let RotationUtils = RotationUtils_1 = class RotationUtils {
    constructor(rotation) {
        this.enabled = false;
        this.rotation = rotation;
    }
    /** Set the rotation speed */
    setRotationSpeed(rotationHz) {
        this.rotation.rotationHz = rotationHz;
        this.enabled = rotationHz !== 0;
        return this;
    }
    /** Build the rotation filter */
    build() {
        return this.rotation;
    }
};
__decorate([
    validators_1.check(function (method, rotationHz) {
        if (typeof rotationHz !== "number" || isNaN(rotationHz))
            throw new TypeError("Parameter 'rotationHz' must be present and be a number");
        return method(rotationHz);
    })
], RotationUtils.prototype, "setRotationSpeed", null);
RotationUtils = RotationUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        let rotation = args[0];
        let enabled = false;
        if (typeof rotation === "object" &&
            rotation !== null &&
            rotation.rotationHz !== 0)
            enabled = true;
        else
            rotation = { rotationHz: 5 };
        const instance = new target(rotation);
        instance.enabled = enabled;
        return instance;
    })
], RotationUtils);
exports.RotationUtils = RotationUtils;
/** Distortion filter builder utility */
let DistortionUtils = DistortionUtils_1 = class DistortionUtils {
    constructor(distortion) {
        this.enabled = false;
        this.distortion = distortion;
    }
    /** Set the sin offset */
    setSinOffset(sinOffset) {
        this.distortion.sinOffset = sinOffset;
        if (sinOffset !== 0)
            this.enabled = true;
        else if (this.distortion.sinOffset === 0 &&
            this.distortion.sinScale === 1 &&
            this.distortion.cosOffset === 0 &&
            this.distortion.cosScale === 1 &&
            this.distortion.tanOffset === 0 &&
            this.distortion.tanScale === 1 &&
            this.distortion.offset === 0 &&
            this.distortion.scale === 1)
            this.enabled = false;
        return this;
    }
    /** Set the sin scale */
    setSinScale(sinScale) {
        this.distortion.sinScale = sinScale;
        if (sinScale !== 1)
            this.enabled = true;
        else if (this.distortion.sinOffset === 0 &&
            this.distortion.sinScale === 1 &&
            this.distortion.cosOffset === 0 &&
            this.distortion.cosScale === 1 &&
            this.distortion.tanOffset === 0 &&
            this.distortion.tanScale === 1 &&
            this.distortion.offset === 0 &&
            this.distortion.scale === 1)
            this.enabled = false;
        return this;
    }
    /** Set the cos offset */
    setCosOffset(cosOffset) {
        this.distortion.cosOffset = cosOffset;
        if (cosOffset !== 0)
            this.enabled = true;
        else if (this.distortion.sinOffset === 0 &&
            this.distortion.sinScale === 1 &&
            this.distortion.cosOffset === 0 &&
            this.distortion.cosScale === 1 &&
            this.distortion.tanOffset === 0 &&
            this.distortion.tanScale === 1 &&
            this.distortion.offset === 0 &&
            this.distortion.scale === 1)
            this.enabled = false;
        return this;
    }
    /** Set the cos scale */
    setCosScale(cosScale) {
        this.distortion.cosScale = cosScale;
        if (cosScale !== 1)
            this.enabled = true;
        else if (this.distortion.sinOffset === 0 &&
            this.distortion.sinScale === 1 &&
            this.distortion.cosOffset === 0 &&
            this.distortion.cosScale === 1 &&
            this.distortion.tanOffset === 0 &&
            this.distortion.tanScale === 1 &&
            this.distortion.offset === 0 &&
            this.distortion.scale === 1)
            this.enabled = false;
        return this;
    }
    /** Set the tan offset */
    setTanOffset(tanOffset) {
        this.distortion.tanOffset = tanOffset;
        if (tanOffset !== 0)
            this.enabled = true;
        else if (this.distortion.sinOffset === 0 &&
            this.distortion.sinScale === 1 &&
            this.distortion.cosOffset === 0 &&
            this.distortion.cosScale === 1 &&
            this.distortion.tanOffset === 0 &&
            this.distortion.tanScale === 1 &&
            this.distortion.offset === 0 &&
            this.distortion.scale === 1)
            this.enabled = false;
        return this;
    }
    /** Set the tan scale */
    setTanScale(tanScale) {
        this.distortion.tanScale = tanScale;
        if (tanScale !== 1)
            this.enabled = true;
        else if (this.distortion.sinOffset === 0 &&
            this.distortion.sinScale === 1 &&
            this.distortion.cosOffset === 0 &&
            this.distortion.cosScale === 1 &&
            this.distortion.tanOffset === 0 &&
            this.distortion.tanScale === 1 &&
            this.distortion.offset === 0 &&
            this.distortion.scale === 1)
            this.enabled = false;
        return this;
    }
    /** Set the offset */
    setOffset(offset) {
        this.distortion.offset = offset;
        if (offset !== 0)
            this.enabled = true;
        else if (this.distortion.sinOffset === 0 &&
            this.distortion.sinScale === 1 &&
            this.distortion.cosOffset === 0 &&
            this.distortion.cosScale === 1 &&
            this.distortion.tanOffset === 0 &&
            this.distortion.tanScale === 1 &&
            this.distortion.offset === 0 &&
            this.distortion.scale === 1)
            this.enabled = false;
        return this;
    }
    /** Set the scale */
    setScale(scale) {
        this.distortion.scale = scale;
        if (scale !== 1)
            this.enabled = true;
        else if (this.distortion.sinOffset === 0 &&
            this.distortion.sinScale === 1 &&
            this.distortion.cosOffset === 0 &&
            this.distortion.cosScale === 1 &&
            this.distortion.tanOffset === 0 &&
            this.distortion.tanScale === 1 &&
            this.distortion.offset === 0 &&
            this.distortion.scale === 1)
            this.enabled = false;
        return this;
    }
    /** Build the distortion filter */
    build() {
        return this.distortion;
    }
};
__decorate([
    validators_1.check(function (method, sinOffset) {
        if (typeof sinOffset !== "number" || isNaN(sinOffset))
            throw new TypeError("Parameter 'sinOffset' must be present and be a number");
        return method(sinOffset);
    })
], DistortionUtils.prototype, "setSinOffset", null);
__decorate([
    validators_1.check(function (method, sinScale) {
        if (typeof sinScale !== "number" || isNaN(sinScale))
            throw new TypeError("Parameter 'sinScale' must be present and be a number");
        return method(sinScale);
    })
], DistortionUtils.prototype, "setSinScale", null);
__decorate([
    validators_1.check(function (method, cosOffset) {
        if (typeof cosOffset !== "number" || isNaN(cosOffset))
            throw new TypeError("Parameter 'cosOffset' must be present and be a number");
        return method(cosOffset);
    })
], DistortionUtils.prototype, "setCosOffset", null);
__decorate([
    validators_1.check(function (method, cosScale) {
        if (typeof cosScale !== "number" || isNaN(cosScale))
            throw new TypeError("Parameter 'cosScale' must be present and be a number");
        return method(cosScale);
    })
], DistortionUtils.prototype, "setCosScale", null);
__decorate([
    validators_1.check(function (method, tanOffset) {
        if (typeof tanOffset !== "number" || isNaN(tanOffset))
            throw new TypeError("Parameter 'tanOffset' must be present and be a number");
        return method(tanOffset);
    })
], DistortionUtils.prototype, "setTanOffset", null);
__decorate([
    validators_1.check(function (method, tanScale) {
        if (typeof tanScale !== "number" || isNaN(tanScale))
            throw new TypeError("Parameter 'tanScale' must be present and be a number");
        return method(tanScale);
    })
], DistortionUtils.prototype, "setTanScale", null);
__decorate([
    validators_1.check(function (method, offset) {
        if (typeof offset !== "number" || isNaN(offset))
            throw new TypeError("Parameter 'offset' must be present and be a number");
        return method(offset);
    })
], DistortionUtils.prototype, "setOffset", null);
__decorate([
    validators_1.check(function (method, scale) {
        if (typeof scale !== "number" || isNaN(scale))
            throw new TypeError("Parameter 'scale' must be present and be a number");
        return method(scale);
    })
], DistortionUtils.prototype, "setScale", null);
DistortionUtils = DistortionUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        let distortion = args[0];
        let enabled = false;
        if (typeof distortion === "object" &&
            distortion !== null &&
            (distortion.sinOffset !== 0 ||
                distortion.sinScale !== 1 ||
                distortion.cosOffset !== 0 ||
                distortion.cosScale !== 1 ||
                distortion.tanOffset !== 0 ||
                distortion.tanScale !== 1 ||
                distortion.offset !== 0 ||
                distortion.scale !== 1)) {
            enabled = true;
        }
        else {
            distortion = {
                sinOffset: 0,
                sinScale: 1,
                cosOffset: 0,
                cosScale: 1,
                tanOffset: 0,
                tanScale: 1,
                offset: 0,
                scale: 1
            };
        }
        const instance = new target(distortion);
        instance.enabled = enabled;
        return instance;
    })
], DistortionUtils);
exports.DistortionUtils = DistortionUtils;
/** ChannelMix filter builder utility */
let ChannelMixUtils = ChannelMixUtils_1 = class ChannelMixUtils {
    constructor(channelMix) {
        this.enabled = false;
        this.channelMix = channelMix;
    }
    /** Set left to left mix, must be between 0 to 1 */
    setLeftToLeft(leftToLeft) {
        this.channelMix.leftToLeft = leftToLeft;
        if (leftToLeft !== 1)
            this.enabled = true;
        else if (this.channelMix.leftToLeft === 1 &&
            this.channelMix.leftToRight === 0 &&
            this.channelMix.rightToLeft === 0 &&
            this.channelMix.rightToRight === 1)
            this.enabled = false;
        return this;
    }
    /** Set left to right mix, must be between 0 to 1 */
    setLeftToRight(leftToRight) {
        this.channelMix.leftToRight = leftToRight;
        if (leftToRight !== 0)
            this.enabled = true;
        else if (this.channelMix.leftToLeft === 1 &&
            this.channelMix.leftToRight === 0 &&
            this.channelMix.rightToLeft === 0 &&
            this.channelMix.rightToRight === 1)
            this.enabled = false;
        return this;
    }
    /** Set right to left mix, must be between 0 to 1 */
    setRightToLeft(rightToLeft) {
        this.channelMix.rightToLeft = rightToLeft;
        if (rightToLeft !== 0)
            this.enabled = true;
        else if (this.channelMix.leftToLeft === 1 &&
            this.channelMix.leftToRight === 0 &&
            this.channelMix.rightToLeft === 0 &&
            this.channelMix.rightToRight === 1)
            this.enabled = false;
        return this;
    }
    /** Set right to right mix, must be between 0 to 1 */
    setRightToRight(rightToRight) {
        this.channelMix.rightToRight = rightToRight;
        if (rightToRight !== 1)
            this.enabled = true;
        else if (this.channelMix.leftToLeft === 1 &&
            this.channelMix.leftToRight === 0 &&
            this.channelMix.rightToLeft === 0 &&
            this.channelMix.rightToRight === 1)
            this.enabled = false;
        return this;
    }
    /** Build the channel mix filter */
    build() {
        return this.channelMix;
    }
};
__decorate([
    validators_1.check(function (method, leftToLeft) {
        if (typeof leftToLeft !== "number" || isNaN(leftToLeft))
            throw new TypeError("Parameter 'leftToLeft' must be present and be a number");
        if (leftToLeft < 0 ||
            leftToLeft > 1)
            throw new TypeError("Parameter 'leftToLeft' must be between 0 to 1");
        return method(leftToLeft);
    })
], ChannelMixUtils.prototype, "setLeftToLeft", null);
__decorate([
    validators_1.check(function (method, leftToRight) {
        if (typeof leftToRight !== "number" || isNaN(leftToRight))
            throw new TypeError("Parameter 'leftToRight' must be present and be a number");
        if (leftToRight < 0 ||
            leftToRight > 1)
            throw new TypeError("Parameter 'leftToRight' must be between 0 to 1");
        return method(leftToRight);
    })
], ChannelMixUtils.prototype, "setLeftToRight", null);
__decorate([
    validators_1.check(function (method, rightToLeft) {
        if (typeof rightToLeft !== "number" || isNaN(rightToLeft))
            throw new TypeError("Parameter 'rightToLeft' must be present and be a number");
        if (rightToLeft < 0 ||
            rightToLeft > 1)
            throw new TypeError("Parameter 'rightToLeft' must be between 0 to 1");
        return method(rightToLeft);
    })
], ChannelMixUtils.prototype, "setRightToLeft", null);
__decorate([
    validators_1.check(function (method, rightToRight) {
        if (typeof rightToRight !== "number" || isNaN(rightToRight))
            throw new TypeError("Parameter 'rightToRight' must be present and be a number");
        if (rightToRight < 0 ||
            rightToRight > 1)
            throw new TypeError("Parameter 'rightToRight' must be between 0 to 1");
        return method(rightToRight);
    })
], ChannelMixUtils.prototype, "setRightToRight", null);
ChannelMixUtils = ChannelMixUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        let channelMix = args[0];
        let enabled = false;
        if (typeof channelMix === "object" &&
            channelMix !== null &&
            (channelMix.leftToLeft !== 1 ||
                channelMix.leftToRight !== 0 ||
                channelMix.rightToLeft !== 0 ||
                channelMix.rightToRight !== 1)) {
            enabled = true;
        }
        else {
            channelMix = {
                leftToLeft: 1,
                leftToRight: 0,
                rightToLeft: 0,
                rightToRight: 1
            };
        }
        const instance = new target(channelMix);
        instance.enabled = enabled;
        return instance;
    })
], ChannelMixUtils);
exports.ChannelMixUtils = ChannelMixUtils;
/** LowPass filter builder utility */
let LowPassUtils = LowPassUtils_1 = class LowPassUtils {
    constructor(lowPass) {
        this.enabled = false;
        this.lowPass = lowPass;
    }
    /** Set the smoothing */
    setSmoothing(smoothing) {
        this.lowPass.smoothing = smoothing;
        this.enabled = smoothing !== 20;
        return this;
    }
    /** Build the low pass filter */
    build() {
        return this.lowPass;
    }
};
__decorate([
    validators_1.check(function (method, smoothing) {
        if (typeof smoothing !== "number" || isNaN(smoothing))
            throw new TypeError("Parameter 'smoothing' must be present and be a number");
        return method(smoothing);
    })
], LowPassUtils.prototype, "setSmoothing", null);
LowPassUtils = LowPassUtils_1 = __decorate([
    constructs_1.construct(function (target, args) {
        let lowPass = args[0];
        let enabled = false;
        if (typeof lowPass === "object" &&
            lowPass !== null &&
            lowPass.smoothing !== 20)
            enabled = true;
        else
            lowPass = { smoothing: 20 };
        const instance = new target(lowPass);
        instance.enabled = enabled;
        return instance;
    })
], LowPassUtils);
exports.LowPassUtils = LowPassUtils;
