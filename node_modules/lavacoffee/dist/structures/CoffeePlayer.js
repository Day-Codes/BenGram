"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoffeePlayer = void 0;
const validators_1 = require("../utils/decorators/validators");
const constructs_1 = require("../utils/decorators/constructs");
const constants_1 = require("../utils/constants");
const CoffeeTrack_1 = require("./CoffeeTrack");
const rest_1 = require("../utils/rest");
const filterUtils_1 = require("../utils/filterUtils");
let CoffeePlayer = class CoffeePlayer {
    constructor(lava, options) {
        /** The player position in milliseconds */
        this.position = 0;
        /** Whether the player is currently replaying */
        this.replaying = false;
        /** Whether the player is connected to voice on node-side */
        this.voiceConnected = false;
        /** Timestamp of the time the player was last updated */
        this.lastUpdated = Date.now();
        /** The player filters */
        this.filters = {};
        /** The player loop mode */
        this.loop = constants_1.LoopMode.None;
        /** The player state */
        this.state = constants_1.PlayerStates.Paused;
        /** The player voice state */
        this.voiceState = constants_1.PlayerVoiceStates.Disconnected;
        /** The player voice payload */
        this.voice = Object.create(null);
        /** Whether the player need to be resumed after connected */
        this.needResume = false;
        this.lava = lava;
        const requiredPlugins = options.requiredPlugins ?? [];
        this.queue = new lava.options.structures.Queue();
        this.options = {
            volume: 100,
            selfMute: false,
            selfDeaf: true,
            node: requiredPlugins.length
                ? this.lava.leastLoadFilteredNode(requiredPlugins)?.options.name
                : this.lava.leastLoadNode?.options.name,
            requiredPlugins,
            ...options
        };
        this.lava.players.set(this.options.guildID, this);
        this.lava.emit("playerCreate", this);
        this.setVolume();
    }
    /** The player guildID */
    get guildID() {
        return this.options.guildID;
    }
    /** The player volume */
    get volume() {
        return this.options.volume;
    }
    /** The player voiceID */
    get voiceID() {
        return this.options.voiceID;
    }
    set voiceID(voiceID) {
        if (typeof voiceID !== "string" || !voiceID)
            throw new TypeError("'voiceID' must be a non-empty string");
        this.options.voiceID = voiceID;
    }
    /** Get the player absolute position on the current track */
    get absolutePosition() {
        if (this.position === undefined)
            return 0;
        const { lastUpdated } = this;
        const rawPosition = this.position;
        const additional = this.state === constants_1.PlayerStates.Playing
            ? Date.now() - lastUpdated
            : 0;
        return rawPosition + additional;
    }
    /** The node used by player */
    get node() {
        const node = this.lava.nodes.get(this.options.node);
        if (!node || !node.connected)
            throw new Error("No node is available currently");
        return node;
    }
    /** Move the player to another node */
    setNode(node) {
        try {
            void this.node.send({
                op: constants_1.OpCodes.Destroy,
                guildId: this.options.guildID
            });
            // eslint-disable-next-line no-empty
        }
        catch { }
        this.options.node = node;
        if (this.voiceState === constants_1.PlayerVoiceStates.Connected) {
            if (["op", "guildId", "event", "sessionId"].every(prop => prop in this.voice))
                void this.node.send(this.voice);
            this.connect();
        }
        if (this.queue.current) {
            void this.resolveCurrent().then(() => {
                const payload = {
                    op: constants_1.OpCodes.Play,
                    ...this.playOptions,
                    guildId: this.options.guildID,
                    track: this.queue.current.base64,
                    startTime: this.position,
                    pause: this.state === constants_1.PlayerStates.Paused
                };
                this.setVolume();
                this.patchFilters();
                this.lava.emit("playerReplay", this);
                void this.node.send(payload);
                this.replaying = true;
            });
        }
    }
    /** Connect to the voice channel */
    connect() {
        this.voiceState = constants_1.PlayerVoiceStates.Connecting;
        this.lava.options.send(this.options.guildID, {
            op: 4,
            d: {
                guild_id: this.options.guildID,
                channel_id: this.options.voiceID,
                self_mute: this.options.selfMute,
                self_deaf: this.options.selfDeaf
            }
        });
        this.voiceState = constants_1.PlayerVoiceStates.Connected;
        try {
            if (this.state === constants_1.PlayerStates.Paused && this.needResume) {
                this.pause(false);
            }
            // eslint-disable-next-line no-empty
        }
        catch { }
    }
    /** Disconnect from the voice channel */
    disconnect() {
        this.voiceState = constants_1.PlayerVoiceStates.Disconnecting;
        this.lava.options.send(this.options.guildID, {
            op: 4,
            d: {
                guild_id: this.options.guildID,
                channel_id: null,
                self_mute: false,
                self_deaf: false
            }
        });
        this.voiceState = constants_1.PlayerVoiceStates.Disconnected;
    }
    /** Play the next track in queue */
    async play(options = {}) {
        const prevOfPrevious = this.queue.previous;
        if (this.loop === constants_1.LoopMode.Track ||
            (this.loop === constants_1.LoopMode.Queue && !this.queue.length)) {
            this.queue.previous = this.queue.current;
        }
        else {
            this.queue.progress();
            if (this.loop === constants_1.LoopMode.Queue)
                this.queue.add(this.queue.previous);
        }
        if (!this.queue.current)
            return;
        try {
            await this.resolveCurrent();
        }
        catch (error) {
            this.lava.emit("trackError", this, this.queue.current, error);
            this.queue.current = this.queue.previous;
            this.queue.previous = prevOfPrevious;
            if (this.queue.length)
                await this.play(options);
            return;
        }
        const payload = {
            op: constants_1.OpCodes.Play,
            guildId: this.options.guildID,
            track: this.queue.current.base64,
            startTime: options.startTime,
            endTime: options.endTime
        };
        await this.node.send(payload);
    }
    /** Patch the player filters */
    patchFilters() {
        const payload = {
            op: constants_1.OpCodes.Filters,
            guildId: this.options.guildID,
            ...this.filters
        };
        void this.node.send(payload);
    }
    /** Set the player filters */
    setFilters(filters) {
        this.filters = filters instanceof filterUtils_1.FilterUtils ? filters.build() : filters;
    }
    /** Set the player volume */
    setVolume(volume) {
        this.options.volume = Math.max(Math.min(volume, 1000), 0);
        const payload = {
            op: constants_1.OpCodes.Volume,
            guildId: this.options.guildID,
            volume: this.options.volume
        };
        void this.node.send(payload);
    }
    /** Set the player loop mode */
    setLoop(loopMode) {
        this.loop = loopMode;
    }
    /** Stops the current track, optionally give an amount to skip to, e.g 5 would play the 5th song */
    stop(amount) {
        if (typeof amount === "number" && amount > 1)
            this.queue.splice(0, amount - 1);
        const payload = {
            op: constants_1.OpCodes.Stop,
            guildId: this.options.guildID
        };
        void this.node.send(payload);
    }
    /** Pause the current track */
    pause(pause) {
        this.state = pause ? constants_1.PlayerStates.Paused : constants_1.PlayerStates.Playing;
        const payload = {
            op: constants_1.OpCodes.Pause,
            guildId: this.options.guildID,
            pause
        };
        void this.node.send(payload);
        this.needResume = false;
    }
    /** Seek to the position in current track */
    seek(position) {
        this.position = position;
        const payload = {
            op: constants_1.OpCodes.Seek,
            guildId: this.options.guildID,
            position
        };
        void this.node.send(payload);
    }
    /** Destroy the player */
    destroy() {
        this.state = constants_1.PlayerStates.Destroyed;
        this.disconnect();
        void this.node.send({
            op: constants_1.OpCodes.Destroy,
            guildId: this.options.guildID
        });
        this.lava.players.delete(this.options.guildID);
        this.lava.emit("playerDestroy", this);
    }
    /** Set a property into metadata */
    set(key, value) {
        if (this.options.metadata)
            this.options.metadata[key] = value;
    }
    /** Get a property from metadata */
    get(key) {
        return this.options.metadata?.[key];
    }
    async resolveCurrent() {
        const track = this.queue.current;
        if (CoffeeTrack_1.UnresolvedTrack.isUnresolved(track)) {
            const query = [track.author, track.title].filter(str => str).join(" - ");
            const res = await this.lava.search({ query }, track.requester);
            if (res.loadType !== rest_1.LoadTypes.SearchResult) {
                // eslint-disable-next-line @typescript-eslint/no-throw-literal
                throw res.error ?? {
                    message: "No tracks found.",
                    severity: "COMMON"
                };
            }
            if (track.author) {
                const channelNames = [track.author, `${track.author} - Topic`];
                const originalAudio = res.tracks.find(cTrack => channelNames.some(name => name === cTrack.author || name === cTrack.title));
                if (originalAudio) {
                    this.queue.current = originalAudio;
                    return;
                }
            }
            if (track.duration) {
                const sameDuration = res.tracks.find(cTrack => (cTrack.duration >= (track.duration - 1500)) &&
                    (cTrack.duration <= (track.duration + 1500)));
                if (sameDuration) {
                    this.queue.current = sameDuration;
                    return;
                }
            }
            this.queue.current = res.tracks[0];
        }
    }
};
__decorate([
    validators_1.check(function (method, node) {
        if (this.options.node === node)
            return;
        return method(node);
    })
], CoffeePlayer.prototype, "setNode", null);
__decorate([
    validators_1.check(function (method) {
        if (!this.options.voiceID)
            throw new Error("No voice channel has been set");
        return method();
    })
], CoffeePlayer.prototype, "connect", null);
__decorate([
    validators_1.check(function (method) {
        if (this.voiceState !== constants_1.PlayerVoiceStates.Connected)
            return;
        return method();
    })
], CoffeePlayer.prototype, "disconnect", null);
__decorate([
    validators_1.check(function (method, options) {
        if (typeof options !== "undefined" && (typeof options !== "object" || options === null))
            throw new TypeError("Parameter 'options' must be present and be an object");
        return method(options);
    })
], CoffeePlayer.prototype, "play", null);
__decorate([
    validators_1.check(function (method) {
        if (!this.queue.current)
            return;
        return method();
    })
], CoffeePlayer.prototype, "patchFilters", null);
__decorate([
    validators_1.check(function (method, filters) {
        if (typeof filters !== "object" || filters === null)
            throw new TypeError("Parameter 'filters' must be present and be an object");
        return method(filters);
    })
], CoffeePlayer.prototype, "setFilters", null);
__decorate([
    validators_1.check(function (method, volume) {
        volume = Number(volume);
        if (isNaN(volume))
            volume = this.options.volume;
        return method(volume);
    })
], CoffeePlayer.prototype, "setVolume", null);
__decorate([
    validators_1.check(function (method, loopMode) {
        if (loopMode < constants_1.LoopMode.None || loopMode > constants_1.LoopMode.Queue)
            loopMode = constants_1.LoopMode.None;
        return method(loopMode);
    })
], CoffeePlayer.prototype, "setLoop", null);
__decorate([
    validators_1.check(function (method, amount) {
        if (typeof amount === "number" && amount > 1) {
            if (amount > this.queue.length)
                throw new RangeError("Cannot skip more than the queue length.");
        }
        return method(amount);
    })
], CoffeePlayer.prototype, "stop", null);
__decorate([
    validators_1.check(function (method, pause) {
        if (typeof pause !== "boolean")
            throw new TypeError("Parameter 'pause' must be present and be a boolean");
        if ((pause && this.state === constants_1.PlayerStates.Paused) || !this.queue.totalSize)
            return;
        return method(pause);
    })
], CoffeePlayer.prototype, "pause", null);
__decorate([
    validators_1.check(function (method, position) {
        if (!this.queue.current)
            return;
        position = Number(position);
        if (isNaN(position))
            throw new TypeError("Parameter 'position' must be present and be a number");
        if (position < 0 || position > this.queue.current.duration) {
            position = Math.max(Math.min(position, this.queue.current.duration), 0);
        }
        return method(position);
    })
], CoffeePlayer.prototype, "seek", null);
CoffeePlayer = __decorate([
    constructs_1.constructPlayer()
], CoffeePlayer);
exports.CoffeePlayer = CoffeePlayer;
