"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoffeeQueue = void 0;
const validators_1 = require("../utils/decorators/validators");
/** The player's queue, the `current` property is the currently playing track, think of the rest as the up-coming tracks */
class CoffeeQueue extends Array {
    /** The total duration of the queue */
    get duration() {
        const current = this.current?.duration ?? 0;
        return this.reduce((acc, tr) => acc + (tr.duration ?? 0), current);
    }
    /** The total size of tracks in the queue including the current track */
    get totalSize() {
        return this.length + (this.current ? 1 : 0);
    }
    /** The size of the tracks in the queue */
    get size() {
        return this.length;
    }
    /** Add some track to the queue */
    add(tracks, offset) {
        if (typeof offset === "undefined" && typeof offset !== "number") {
            if (Array.isArray(tracks))
                this.push(...tracks);
            else
                this.push(tracks);
        }
        else if (Array.isArray(tracks)) {
            this.splice(offset, 0, ...tracks);
        }
        else {
            this.splice(offset, 0, tracks);
        }
    }
    /** Removes an amount of tracks using a exclusive start and end exclusive index, returning the removed tracks, EXCLUDING THE `current` TRACK */
    remove(start, end) {
        if (typeof end !== "undefined")
            return this.splice(start, end - start);
        return this.splice(start, 1);
    }
    /** Clear the queue */
    clear() {
        this.length = 0;
    }
    /** Shuffle the queue */
    shuffle() {
        for (let i = this.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this[i], this[j]] = [this[j], this[i]];
        }
    }
    /** Progress to next song */
    progress() {
        this.previous = this.current;
        this.current = this.shift();
        return this.current;
    }
}
__decorate([
    validators_1.Queue.validateTracks()
], CoffeeQueue.prototype, "add", null);
__decorate([
    validators_1.Queue.validatePosition()
], CoffeeQueue.prototype, "remove", null);
exports.CoffeeQueue = CoffeeQueue;
