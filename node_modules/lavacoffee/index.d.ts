// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   tiny-typed-emitter
//   ws
//   undici
//   undici/types/dispatcher

declare module 'lavacoffee' {
    export * from "lavacoffee/dist/structures";
    export * as Utils from "lavacoffee/dist/utils";
    export { FilterUtils as CoffeeFilters } from "lavacoffee/dist/utils";
    export const version: string;
}

declare module 'lavacoffee/dist/structures' {
    export * from "lavacoffee/dist/structures/CoffeeLava";
    export * from "lavacoffee/dist/structures/CoffeeNode";
    export * from "lavacoffee/dist/structures/CoffeePlayer";
    export * from "lavacoffee/dist/structures/CoffeeQueue";
    export * from "lavacoffee/dist/structures/CoffeeTrack";
    export * from "lavacoffee/dist/structures/CoffeeRoutePlanner";
}

declare module 'lavacoffee/dist/utils' {
    export * from "lavacoffee/dist/utils/constants";
    export * from "lavacoffee/dist/utils/filters";
    export * from "lavacoffee/dist/utils/payloads";
    export * from "lavacoffee/dist/utils/rest";
    export * from "lavacoffee/dist/utils/typings";
    export * from "lavacoffee/dist/utils/filterUtils";
}

declare module 'lavacoffee/dist/structures/CoffeeLava' {
    import { CoffeeNode } from "lavacoffee/dist/structures/CoffeeNode";
    import { CoffeePlayer } from "lavacoffee/dist/structures/CoffeePlayer";
    import { LavaOptions, NodeOptions, PlayerOptions, ResumeConfig, SearchQuery, SearchResult } from "lavacoffee/dist/utils/typings";
    import { TypedEmitter } from "tiny-typed-emitter";
    import { TrackEndPayload, TrackExceptionPayload, TrackStartPayload, TrackStuckPayload, VoiceServerUpdate, VoiceStateUpdate, WebSocketClosedPayload } from "lavacoffee/dist/utils/payloads";
    import { CoffeeTrack, UnresolvedTrack } from "lavacoffee/dist/structures/CoffeeTrack";
    import { TrackData, Tracks } from "lavacoffee/dist/utils/rest";
    export interface LavaEvents {
            /** Emitted when a node is created */
            nodeCreate(node: CoffeeNode): void;
            /** Emitted when a node is destroyed */
            nodeDestroy(node: CoffeeNode): void;
            /** Emitted when a node connects */
            nodeConnect(node: CoffeeNode): void;
            /** Emitted when a node lack required plugins after connected */
            nodeMissingPlugins(node: CoffeeNode, missing: string[]): any;
            /** Emitted when a Node reconnects */
            nodeReconnect(node: CoffeeNode): void;
            /** Emitted when a Node disconnects */
            nodeDisconnect(node: CoffeeNode, reason: {
                    code: number;
                    reason: string;
            }): void;
            /** Emitted when a Node has an error */
            nodeError(node: CoffeeNode, error: Error): void;
            /** Emitted whenever any Lavalink event is received */
            nodeRaw(node: CoffeeNode, payload: unknown): void;
            /** Emitted whenever a Player is created */
            playerCreate(player: CoffeePlayer): void;
            /** Emitted whenever a Player is destroyed */
            playerDestroy(player: CoffeePlayer): void;
            /** Emitted whenever a Player is replaying after moving node */
            playerReplay(player: CoffeePlayer): void;
            /** Emitted whenever an error occured when replaying track */
            replayError(player: CoffeePlayer, error: Error): void;
            /** Emitted whenever a Player is moved to other channel */
            playerMove(player: CoffeePlayer, oldChannel: string | undefined, newChannel: string | undefined): void;
            /** Emitted whenever queue is started */
            queueStart(player: CoffeePlayer, track: CoffeeTrack | UnresolvedTrack, payload: TrackStartPayload): void;
            /** Emitted whenever queue is ended */
            queueEnd(player: CoffeePlayer, track: CoffeeTrack | UnresolvedTrack, payload: TrackEndPayload | TrackStuckPayload | TrackExceptionPayload): void;
            /** Emitted whenever a track start */
            trackStart(player: CoffeePlayer, track: CoffeeTrack | UnresolvedTrack, payload: TrackStartPayload): void;
            /** Emitted whenever a track end */
            trackEnd(player: CoffeePlayer, track: CoffeeTrack | UnresolvedTrack, payload: TrackEndPayload): void;
            /** Emitted whenever a track stuck during playback */
            trackStuck(player: CoffeePlayer, track: CoffeeTrack | UnresolvedTrack, payload: TrackStuckPayload): void;
            /** Emitted whenever a track occur an error during playback */
            trackError(player: CoffeePlayer, track: CoffeeTrack | UnresolvedTrack, payload: TrackExceptionPayload): void;
            /** Emitted whenever a voice connection is closed */
            socketClosed(player: CoffeePlayer, payload: WebSocketClosedPayload): void;
    }
    /**
        * The main hub for interacting with Lavalink and using LavaCoffee
        */
    export class CoffeeLava extends TypedEmitter<LavaEvents> {
            clientID?: string;
            options: LavaOptions;
            readonly nodes: Map<string, CoffeeNode>;
            readonly players: Map<string, CoffeePlayer>;
            constructor(options: LavaOptions);
            get leastUsedNode(): CoffeeNode | undefined;
            get leastLoadNode(): CoffeeNode | undefined;
            /** Initiate the Lavalink client */
            init(clientID: string): void;
            /** Searches some tracks based off the URL or the `source` property */
            search(query: SearchQuery, requester?: unknown): Promise<SearchResult>;
            /** Decode the base64 track into TrackData */
            decodeTrack(track: string): Promise<TrackData>;
            /** Decode the base64 tracks into TracksData */
            decodeTracks(tracks: string[]): Promise<Tracks>;
            /** Send voice data to the Lavalink server */
            updateVoiceData(p: VoiceServerUpdate | VoiceStateUpdate): void;
            /** Configure the resume config */
            configResume(config: ResumeConfig): void;
            /** Create a player or return one if it already exists */
            create(options: PlayerOptions): CoffeePlayer;
            /** Return a player or undefined if it doesn't exist */
            get(guildID: string): CoffeePlayer | undefined;
            /** Destroy a player if it exist */
            destroy(guildID: string): void;
            /** Add a node */
            add(nodeOptions: NodeOptions): void;
            leastUsedFilteredNode(plugins: string[]): CoffeeNode | undefined;
            leastLoadFilteredNode(plugins: string[]): CoffeeNode | undefined;
    }
}

declare module 'lavacoffee/dist/structures/CoffeeNode' {
    import WebSocket from "ws";
    import { Pool } from "undici";
    import { CoffeeLava } from "lavacoffee/dist/structures/CoffeeLava";
    import { TypedEmitter } from "tiny-typed-emitter";
    import { NodeOptions, NodeStats, Plugins } from "lavacoffee/dist/utils/typings";
    import { IncomingPayloads, EventPayloads, PlayerUpdatePayload, OutgoingPayloads } from "lavacoffee/dist/utils/payloads";
    import { ResponseData } from "undici/types/dispatcher";
    import { CoffeeRoutePlanner } from "lavacoffee/dist/structures/CoffeeRoutePlanner";
    export interface NodeEvents {
            /** Emitted when node is destroyed */
            destroy(): void;
            /** Emitted when node connects */
            connect(): void;
            /** Emitted when node lack required plugins after connected */
            missingPlugins(missing: string[]): any;
            /** Emitted when node reconnects */
            reconnect(): void;
            /** Emitted when node disconnects */
            disconnect(reason: {
                    code: number;
                    reason: string;
            }): void;
            /** Emitted when node has an error */
            error(error: Error): void;
            /** Emitted whenever any Lavalink incoming message is received */
            raw(payload: IncomingPayloads): void;
            /** Emitted whenever any Lavalink event is received */
            event(payload: EventPayloads): void;
            /** Emitted whenever playerUpdate is received */
            playerUpdate(guildID: string, state: PlayerUpdatePayload["state"]): void;
    }
    export class CoffeeNode extends TypedEmitter<NodeEvents> {
            readonly lava: CoffeeLava;
            /** The node options */
            options: NodeOptions;
            /** The node stats */
            stats: NodeStats;
            /** The node websocket if connected */
            socket?: WebSocket;
            /** Sums of http request calls since created */
            calls: number;
            /** Whether the node already connected via websocket */
            connected: boolean;
            /** Whether the node is resumed from previous session */
            resumed: boolean;
            /** The http clients pool for http calls */
            readonly http: Pool;
            /** THe routePlanner instance to manage route planners */
            readonly routePlanner: CoffeeRoutePlanner;
            /** The list of plugins the node has */
            readonly plugins: Plugins;
            constructor(lava: CoffeeLava, options: NodeOptions);
            /** The node name */
            get name(): string;
            /** The node url */
            get url(): string;
            /** Whether the node allow secure protocol */
            get isSecure(): boolean;
            /**
                * Do http(s) request to the node
                */
            request<T>(endpoint: string): Promise<T>;
            /**
                * Do http(s) post request to the node
                */
            post(endpoint: string, body?: unknown, raw?: boolean): Promise<ResponseData | unknown>;
            /**
                * Connect to the node via socket
                */
            connect(): void;
            /**
                * Destroy the node connection
                */
            destroy(): void;
            /**
                * Send data to the node
                */
            send(data: OutgoingPayloads): Promise<boolean>;
            /** Configure the resume config */
            configResume(): void;
            /** Fetch the plugins the node has */
            fetchPlugins(): Promise<Plugins>;
    }
}

declare module 'lavacoffee/dist/structures/CoffeePlayer' {
    import { CoffeeNode } from "lavacoffee/dist/structures/CoffeeNode";
    import { CoffeeLava } from "lavacoffee/dist/structures/CoffeeLava";
    import { Filters } from "lavacoffee/dist/utils/filters";
    import { CoffeeQueue } from "lavacoffee/dist/structures/CoffeeQueue";
    import { PlayerOptions, PlayOptions } from "lavacoffee/dist/utils/typings";
    import { VoiceUpdatePayload } from "lavacoffee/dist/utils/payloads";
    import { LoopMode, PlayerStates, PlayerVoiceStates } from "lavacoffee/dist/utils/constants";
    import { FilterUtils } from "lavacoffee/dist/utils/filterUtils";
    export class CoffeePlayer {
        /** The queue for the player */
        readonly queue: CoffeeQueue;
        /** The player options */
        readonly options: PlayerOptions;
        /** The player manager */
        readonly lava: CoffeeLava;
        /** The player position in milliseconds */
        position: number;
        /** Whether the player is currently replaying */
        replaying: boolean;
        /** Whether the player is connected to voice on node-side */
        voiceConnected: boolean;
        /** Timestamp of the time the player was last updated */
        lastUpdated: number;
        /** The player filters */
        filters: Filters;
        /** The player loop mode */
        loop: LoopMode;
        /** The player state */
        state: PlayerStates;
        /** The player voice state */
        voiceState: PlayerVoiceStates;
        /** The player voice payload */
        voice: VoiceUpdatePayload;
        /** The player play options if its currently playing */
        playOptions?: PlayOptions;
        /** Whether the player need to be resumed after connected */
        needResume: boolean;
        constructor(lava: CoffeeLava, options: PlayerOptions);
        /** The player guildID */
        get guildID(): string;
        /** The player volume */
        get volume(): number;
        /** The player voiceID */
        get voiceID(): string;
        set voiceID(voiceID: string);
        /** Get the player absolute position on the current track */
        get absolutePosition(): number;
        /** The node used by player */
        get node(): CoffeeNode;
        /** Move the player to another node */
        setNode(node: string): void;
        /** Connect to the voice channel */
        connect(): void;
        /** Disconnect from the voice channel */
        disconnect(): void;
        /** Play the next track in queue */
        play(options?: PlayOptions): Promise<void>;
        /** Patch the player filters */
        patchFilters(): void;
        /** Set the player filters */
        setFilters(filters: Filters | FilterUtils): void;
        /** Set the player volume */
        setVolume(volume?: number): void;
        /** Set the player loop mode */
        setLoop(loopMode: LoopMode): void;
        /** Stops the current track, optionally give an amount to skip to, e.g 5 would play the 5th song */
        stop(amount?: number): void;
        /** Pause the current track */
        pause(pause: boolean): void;
        /** Seek to the position in current track */
        seek(position: number): void;
        /** Destroy the player */
        destroy(): void;
        /** Set a property into metadata */
        set(key: string, value: unknown): void;
        /** Get a property from metadata */
        get<T>(key: string): T | undefined;
    }
}

declare module 'lavacoffee/dist/structures/CoffeeQueue' {
    import { CoffeeTrack, UnresolvedTrack } from "lavacoffee/dist/structures/CoffeeTrack";
    /** The player's queue, the `current` property is the currently playing track, think of the rest as the up-coming tracks */
    export class CoffeeQueue extends Array<CoffeeTrack | UnresolvedTrack> {
        /** The current track */
        current?: CoffeeTrack | UnresolvedTrack;
        /** The previous track */
        previous?: CoffeeTrack | UnresolvedTrack;
        /** The total duration of the queue */
        get duration(): number;
        /** The total size of tracks in the queue including the current track */
        get totalSize(): number;
        /** The size of the tracks in the queue */
        get size(): number;
        /** Add some track to the queue */
        add(tracks: (CoffeeTrack | UnresolvedTrack) | (CoffeeTrack | UnresolvedTrack)[], offset?: number): void;
        /** Removes an amount of tracks using a exclusive start and end exclusive index, returning the removed tracks, EXCLUDING THE `current` TRACK */
        remove(start: number, end?: number): (CoffeeTrack | UnresolvedTrack)[];
        /** Clear the queue */
        clear(): void;
        /** Shuffle the queue */
        shuffle(): void;
        /** Progress to next song */
        progress(): CoffeeTrack | UnresolvedTrack | undefined;
    }
}

declare module 'lavacoffee/dist/structures/CoffeeTrack' {
    import { TrackData, TrackInfo } from "lavacoffee/dist/utils/rest";
    export interface ITrack {
        /** The title of the track */
        title: string;
        /** The identifier of the track */
        identifier: string;
        /** The author of the track */
        author: string;
        /** The duration of the track */
        duration: number;
        /** Whether the track is seekable */
        isSeekable: boolean;
        /** Whether the track is a stream */
        isStream: boolean;
        /** The url of the track */
        url: string;
        /** The source of the track */
        source: string;
    }
    export class CoffeeTrack implements ITrack {
        /** The base 64 encoded of track */
        readonly base64: string;
        /** The requester of the track if any */
        readonly requester?: unknown;
        title: string;
        identifier: string;
        author: string;
        duration: number;
        isSeekable: boolean;
        isStream: boolean;
        url: string;
        source: string;
        constructor(track: TrackData, requester?: unknown);
        /** Check if obj is a valid Track */
        static isTrack(obj: unknown): obj is CoffeeTrack;
        /** Display thumbnail url if source is youtube */
        displayThumbnail(size?: string): string | undefined;
        /** Build TrackInfo into ITrack */
        build(info: TrackInfo): void;
    }
    export class UnresolvedTrack {
        /** Supposely the title of the track */
        readonly title: string;
        /** Supposably the author of the track */
        readonly author?: string | undefined;
        /** Supposably the duration of the track */
        readonly duration?: number | undefined;
        /** The requester of the track if any */
        readonly requester?: unknown;
        constructor(
        /** Supposely the title of the track */
        title: string, 
        /** Supposably the author of the track */
        author?: string | undefined, 
        /** Supposably the duration of the track */
        duration?: number | undefined, 
        /** The requester of the track if any */
        requester?: unknown);
        static isUnresolved(obj: unknown): obj is UnresolvedTrack;
    }
}

declare module 'lavacoffee/dist/structures/CoffeeRoutePlanner' {
    import { RoutePlanners } from "lavacoffee/dist/utils";
    import { CoffeeNode } from "lavacoffee/dist/structures/CoffeeNode";
    export class CoffeeRoutePlanner {
        node: CoffeeNode;
        constructor(node: CoffeeNode);
        /** Get the routePlanner status */
        status(): Promise<RoutePlanners | undefined>;
        /** Unmark a failed address */
        freeAddress(address: string): Promise<boolean>;
        /** Unmark all failed address */
        freeAllAddress(): Promise<boolean>;
    }
}

declare module 'lavacoffee/dist/utils/constants' {
    export enum OpCodes {
        VoiceUpdate = "voiceUpdate",
        Play = "play",
        Stop = "stop",
        Pause = "pause",
        Seek = "seek",
        Volume = "volume",
        Filters = "filters",
        Destroy = "destroy",
        ConfigResume = "configureResuming"
    }
    export enum OpIncoming {
        PlayerUpdate = "playerUpdate",
        Stats = "stats",
        Event = "event"
    }
    export enum EventTypes {
        TrackStart = "TrackStartEvent",
        TrackEnd = "TrackEndEvent",
        TrackException = "TrackExceptionEvent",
        TrackStuck = "TrackStuckEvent",
        WebSocketClosed = "WebSocketClosedEvent"
    }
    export enum LoopMode {
        None = 0,
        Track = 1,
        Queue = 2
    }
    export enum PlayerStates {
        Playing = 0,
        Paused = 1,
        Destroyed = 2
    }
    export enum PlayerVoiceStates {
        Connecting = 0,
        Connected = 1,
        Disconnecting = 2,
        Disconnected = 3
    }
    export enum RoutePlanner {
        Balancing = "BalancingIpRoutePlanner",
        Rotating = "RotatingIpRoutePlanner",
        Nano = "NanoIpRoutePlanner",
        RotatingNano = "RotatingNanoIpRoutePlanner"
    }
    export enum IpBlock {
        Ipv4 = "Inet4Address",
        Ipv6 = "Inet6Address"
    }
}

declare module 'lavacoffee/dist/utils/filters' {
    export interface Filters {
        /** The volume filter */
        volume?: number;
        /** The equalizer filters */
        equalizer?: Equalizer[];
        /** Uses equalization to eliminate part of a band, usually targeting vocals */
        karaoke?: Karaoke;
        /** Changes the speed, pitch, and rate. All default to 1 */
        timescale?: TimeScale;
        /** Uses amplification to create a shuddering effect, where the volume quickly oscillates */
        tremolo?: Tremolo;
        /** Similar to tremolo. While tremolo oscillates the volume, vibrato oscillates the pitch */
        vibrato?: Vibrato;
        /** Rotates the sound around the stereo channels/user headphones aka Audio Panning */
        rotation?: Rotation;
        /** Distortion effect. It can generate some pretty unique audio effects */
        distortion?: Distortion;
        /** Mixes both channels (left and right), with a configurable factor on how much each channel affects the other */
        channelMix?: ChannelMix;
        /** Higher frequencies get suppressed, while lower frequencies pass through this filter, thus the name low pass */
        lowPass?: LowPass;
    }
    export interface Equalizer {
        /** The equalizer band, can be 0-14 */
        band: number;
        /** Multipler for the given band, can be 0.25 to 1.0 */
        gain: number;
    }
    export interface Karaoke {
        level: number;
        monoLevel: number;
        filterBand: number;
        filterWidth: number;
    }
    export interface TimeScale {
        speed: number;
        pitch: number;
        rate: number;
    }
    export interface Tremolo {
        /** 0 < x */
        frequency: number;
        /** 0 < x <= 1 */
        depth: number;
    }
    export interface Vibrato {
        /** 0 < x <= 14 */
        frequency: number;
        /** 0 < x <= 1 */
        depth: number;
    }
    export interface Rotation {
        /** The frequency of the audio rotating around the listener in Hz. 0.2 is similar to the example video above */
        rotationHz: number;
    }
    export interface Distortion {
        sinOffset: number;
        sinScale: number;
        cosOffset: number;
        cosScale: number;
        tanOffset: number;
        tanScale: number;
        offset: number;
        scale: number;
    }
    export interface ChannelMix {
        leftToLeft: number;
        leftToRight: number;
        rightToLeft: number;
        rightToRight: number;
    }
    export interface LowPass {
        smoothing: number;
    }
}

declare module 'lavacoffee/dist/utils/payloads' {
    import { Filters } from "lavacoffee/dist/utils/filters";
    import { NodeStats } from "lavacoffee/dist/utils/typings";
    import { OpCodes, OpIncoming, EventTypes } from "lavacoffee/dist/utils/constants";
    export interface VoiceServerUpdate {
        op: 0;
        s: number;
        t: "VOICE_SERVER_UPDATE";
        d: {
            token: string;
            guild_id: string;
            endpoint: string;
        };
    }
    export interface VoiceStateUpdate {
        op: 0;
        s: number;
        t: "VOICE_STATE_UPDATE";
        d: {
            guild_id: string;
            channel_id?: string;
            user_id: string;
            session_id: string;
            deaf: boolean;
            mute: boolean;
            self_deaf: boolean;
            self_mute: boolean;
            self_stream?: boolean;
            self_video: boolean;
            suppress: boolean;
            request_to_speak_timestamp?: number;
        };
    }
    export interface OutgoingPayload {
        op: OpCodes;
        guildId: string;
    }
    export type OutgoingPayloads = VoiceUpdatePayload | PlayPayload | StopPayload | PausePayload | SeekPayload | VolumePayload | FiltersPayload | DestroyPayload | ConfigResumePayload;
    export interface VoiceUpdatePayload extends OutgoingPayload {
        op: OpCodes.VoiceUpdate;
        event: VoiceServerUpdate["d"];
        sessionId: string;
    }
    export interface PlayPayload extends OutgoingPayload {
        op: OpCodes.Play;
        track: string;
        startTime?: number;
        endTime?: number;
        volume?: number;
        noReplace?: boolean;
        pause?: boolean;
    }
    export interface StopPayload extends OutgoingPayload {
        op: OpCodes.Stop;
    }
    export interface PausePayload extends OutgoingPayload {
        op: OpCodes.Pause;
        pause: boolean;
    }
    export interface SeekPayload extends OutgoingPayload {
        op: OpCodes.Seek;
        position: number;
    }
    export interface VolumePayload extends OutgoingPayload {
        op: OpCodes.Volume;
        volume: number;
    }
    export interface FiltersPayload extends OutgoingPayload, Filters {
        op: OpCodes.Filters;
    }
    export interface DestroyPayload extends OutgoingPayload {
        op: OpCodes.Destroy;
    }
    export interface ConfigResumePayload {
        op: OpCodes.ConfigResume;
        key: string;
        timeout: number;
    }
    export interface IncomingPayload {
        op: OpIncoming;
    }
    export type IncomingPayloads = PlayerUpdatePayload | StatsPayload | EventPayloads;
    export interface PlayerUpdatePayload extends IncomingPayload {
        op: OpIncoming.PlayerUpdate;
        guildId: string;
        state: {
            time: number;
            position: number;
            connected: boolean;
        };
    }
    export interface StatsPayload extends IncomingPayload, NodeStats {
        op: OpIncoming.Stats;
    }
    export interface EventPayload extends IncomingPayload {
        op: OpIncoming.Event;
        type: EventTypes;
        guildId: string;
    }
    export type EventPayloads = TrackStartPayload | TrackEndPayload | TrackExceptionPayload | TrackStuckPayload | WebSocketClosedPayload;
    export interface TrackStartPayload extends EventPayload {
        type: EventTypes.TrackStart;
        track: string;
    }
    export interface TrackEndPayload extends EventPayload {
        type: EventTypes.TrackEnd;
        track: string;
        reason: string;
    }
    export interface TrackExceptionPayload extends EventPayload {
        type: EventTypes.TrackException;
        track: string;
        exception: {
            message: string;
            severity: string;
            cause: string;
        };
    }
    export interface TrackStuckPayload extends EventPayload {
        type: EventTypes.TrackStuck;
        track: string;
        thresholdMs: number;
    }
    export interface WebSocketClosedPayload extends EventPayload {
        type: EventTypes.WebSocketClosed;
        code: number;
        reason: string;
        byRemote: boolean;
    }
}

declare module 'lavacoffee/dist/utils/rest' {
    import { IpBlock, RoutePlanner } from "lavacoffee/dist/utils/constants";
    export enum LoadTypes {
        TrackLoaded = "TRACK_LOADED",
        PlaylistLoaded = "PLAYLIST_LOADED",
        SearchResult = "SEARCH_RESULT",
        NoMatches = "NO_MATCHES",
        LoadFailed = "LOAD_FAILED"
    }
    export interface TrackInfo {
        identifier: string;
        isSeekable: boolean;
        author: string;
        length: number;
        isStream: boolean;
        title: string;
        uri: string;
        sourceName: string;
    }
    export interface TrackData {
        track: string;
        info: TrackInfo;
    }
    export type Tracks = TrackData[];
    export interface TracksData {
        loadType: LoadTypes;
        tracks: Tracks;
        playlistInfo?: {
            name: string;
            selectedTrack: number;
        };
        exception?: {
            message: string;
            severity: string;
        };
    }
    export interface RoutePlannerStatus {
        class: RoutePlanner;
        details: RoutePlannerDetails;
    }
    export interface RoutePlannerDetails {
        ipBlock: {
            type: IpBlock;
            size: string;
        };
        failingAddresses: {
            address: string;
            failingTimestamp: number;
            failingTime: string;
        }[];
    }
    /** [RoutePlanner](https://github.com/freyacodes/Lavalink/blob/master/ROUTEPLANNERS.md) */
    export type RoutePlanners = BalancingRoutePlanner | RotatingRoutePlanner | NanoRoutePlanner | RotatingNanoRoutePlanner;
    export interface BalancingRoutePlanner extends RoutePlannerStatus {
        class: RoutePlanner.Balancing;
    }
    export interface RotatingRoutePlanner extends RoutePlannerStatus {
        class: RoutePlanner.Rotating;
        details: RotatingRoutePlannerDetails;
    }
    export interface RotatingRoutePlannerDetails extends RoutePlannerDetails {
        rotateIndex: string;
        ipIndex: string;
        currentAddress: string;
    }
    export interface NanoRoutePlanner extends RoutePlannerStatus {
        class: RoutePlanner.Nano;
        details: NanoRoutePlannerDetails;
    }
    export interface NanoRoutePlannerDetails extends RoutePlannerDetails {
        currentAddressIndex: string;
    }
    export interface RotatingNanoRoutePlanner extends RoutePlannerStatus {
        class: RoutePlanner.RotatingNano;
        details: RotatingNanoRoutePlannerDetails;
    }
    export interface RotatingNanoRoutePlannerDetails extends RoutePlannerDetails {
        blockIndex: string;
        currentAddressIndex: string;
    }
}

declare module 'lavacoffee/dist/utils/typings' {
    import { CoffeeLava, CoffeeNode, CoffeePlayer, CoffeeQueue } from "lavacoffee/dist/structures";
    import { CoffeeTrack } from "lavacoffee/dist/structures/CoffeeTrack";
    import { LoadTypes } from "lavacoffee/dist/utils/rest";
    export interface NodeOptions {
        /** The url for the node */
        url: string;
        /** The name for the node. */
        name: string;
        /** The password for the node */
        password?: string;
        /** Whether the host uses SSL. */
        secure?: boolean;
        /** The retryAmount for the node. */
        retryAmount?: number;
        /** The retryDelay for the node. */
        retryDelay?: number;
        /** The timeout used for api calls */
        requestTimeout?: number;
        /** The max http connections that can be opened at once, null for unlimited */
        maxConnections?: number | null;
    }
    export interface NodeMemoryStats {
        /** The free memory of the allocated amount. */
        free: number;
        /** The used memory of the allocated amount. */
        used: number;
        /** The total allocated memory. */
        allocated: number;
        /** The reservable memory. */
        reservable: number;
    }
    export interface NodeCPUStats {
        /** The core amount the host machine has. */
        cores: number;
        /** The system load. */
        systemLoad: number;
        /** The lavalink load. */
        lavalinkLoad: number;
    }
    export interface NodeFrameStats {
        /** The amount of sent frames. */
        sent: number;
        /** The amount of nulled frames. */
        nulled: number;
        /** The amount of deficit frames. */
        deficit: number;
    }
    export interface NodeStats {
        /** The amount of players on the node. */
        players: number;
        /** The amount of playing players on the node. */
        playingPlayers: number;
        /** The uptime for the node. */
        uptime: number;
        /** The memory stats for the node. */
        memory: NodeMemoryStats;
        /** The cpu stats for the node. */
        cpu: NodeCPUStats;
        /** Timestamp of the time the stats was updated */
        lastUpdated: number;
        /** The frame stats for the node. */
        frameStats?: NodeFrameStats;
    }
    export type SearchPlatform = "yt" | "ytm" | "sc";
    export interface VoiceStatePayload {
        op: number;
        d: {
            guild_id: string;
            channel_id: string | null;
            self_mute: boolean;
            self_deaf: boolean;
        };
    }
    export interface LavaOptions {
        /** The value to use for 'Client-Name' header */
        clientName?: string;
        /** The shards count */
        shards?: number;
        /** Whether players should automatically play next song */
        autoPlay?: boolean;
        /** The default search platform to use, can be "yt" for youtube, "ytm" for youtube music, and "sc" for soundcloud */
        defaultSearchPlatform?: SearchPlatform;
        /** Whether to replay track automatically when node used on player is disconnected */
        autoReplay?: boolean;
        /** Wether to resume voice connection if socket closed unexpectedly */
        autoResume?: boolean;
        /** The config for resuming */
        resumeConfig?: ResumeConfig;
        /** The used structures for the instance */
        structures?: Structures;
        /** Whether to use system load or lavalink load for load balancing, default to system */
        balanceLoad?: "system" | "lavalink";
        /** Required plugins for the nodes, a node won't be used if it doesn't have the required plugins */
        requiredPlugins?: string[];
        /** Function to send voice state to the websocket */
        send(guildID: string, voiceState: VoiceStatePayload): any;
    }
    export interface SearchQuery {
        /** The query to search for */
        query: string;
        /** Whether to allow using search */
        allowSearch?: boolean;
        /** The source to search from */
        source?: SearchPlatform;
        /** Required plugins for the node used to query */
        requiredPlugins?: string[];
    }
    export interface PlayerOptions {
        /** The guild the Player belongs to */
        guildID: string;
        /** The voice channel the Player belongs to */
        voiceID?: string;
        /** The node the Player use */
        node?: string;
        /** The initial volume the Player will use */
        volume?: number;
        /** If the player should mute itself */
        selfMute?: boolean;
        /** If the player should deaf itself */
        selfDeaf?: boolean;
        /** Additional metadata for player, if any */
        metadata?: Record<string, unknown>;
        /** Required plugins for the node used to play */
        requiredPlugins?: string[];
    }
    export interface PlayOptions {
        /** The position to start the track */
        startTime?: number;
        /** The position to end the track */
        endTime?: number;
    }
    export interface Playlist {
        /** The playlist name */
        name: string;
        /** The selected track, if any */
        selectedTrack: CoffeeTrack | null;
        /** Playlist total duration */
        duration: number;
    }
    export interface SearchResult {
        /** Load type from searching */
        loadType: LoadTypes;
        /** The tracks from searching */
        tracks: CoffeeTrack[];
        /** The playlist info if load type is playlist */
        playlist?: Playlist;
        /** Error from searching, if failed */
        error?: {
            message: string;
            severity: string;
        };
    }
    export interface ResumeConfig {
        /** The resume key for resuming lavalink session */
        key: string;
        /** The timeout for the session, if timeout is passed before resumed, it can't be resumed anymore */
        timeout?: number;
        /** The function to create and handle player after resuming */
        handle(lava: CoffeeLava, guildID: string, callback: (player: CoffeePlayer) => void): any;
    }
    export interface Structures {
        Node?: new (lava: CoffeeLava, options: NodeOptions) => CoffeeNode;
        Player?: new (lava: CoffeeLava, options: PlayerOptions) => CoffeePlayer;
        Queue?: new () => CoffeeQueue;
    }
    export interface PluginRaw {
        name: string;
        version: string;
    }
    export type PluginsRaw = PluginRaw[];
    /** K = pluginName, V = pluginVersion */
    export type Plugins = Map<string, string>;
}

declare module 'lavacoffee/dist/utils/filterUtils' {
    import "../structures";
    import { ChannelMix, Distortion, Equalizer, Filters, Karaoke, LowPass, Rotation, TimeScale, Tremolo, Vibrato } from "lavacoffee/dist/utils/filters";
    /** Filters builder utility */
    export class FilterUtils {
        volume?: number;
        equalizers: EqualizerUtils;
        karaoke: KaraokeUtils;
        timescale: TimescaleUtils;
        tremolo: TremoloUtils;
        vibrato: VibratoUtils;
        rotation: RotationUtils;
        distortion: DistortionUtils;
        channelMix: ChannelMixUtils;
        lowPass: LowPassUtils;
        constructor(filters: Filters);
        /** Set the filter volume */
        setVolume(volume: number): this;
        /** Build the filters */
        build(): Filters;
    }
    /** Equalizer filter builder utility */
    export class EqualizerUtils {
        enabled: boolean;
        readonly equalizers: Map<number, Equalizer>;
        constructor(equalizers?: Equalizer[]);
        /** Set a band equalizer, band must be between 0 to 14, gain must be between -0.25 to 1 */
        setBand(band: number, gain: number): this;
        /** Clear the equalizers filter */
        clear(): this;
        /** Build the equalizers */
        build(): Equalizer[];
    }
    /** Karaoke filter builder utility */
    export class KaraokeUtils {
        enabled: boolean;
        readonly karaoke: Karaoke;
        constructor(karaoke?: Karaoke);
        /** Set the level */
        setLevel(level: number): this;
        /** Set the mono level */
        setMonoLevel(monoLevel: number): this;
        /** Set the filter band */
        setFilterBand(filterBand: number): this;
        /** Set the filter width */
        setFilterWidth(filterWidth: number): this;
        /** Disable the karaoke filter */
        disable(): this;
        /** Build the karaoke filter */
        build(): Karaoke;
    }
    /** Timescale filter builder utility */
    export class TimescaleUtils {
        enabled: boolean;
        readonly timescale: TimeScale;
        constructor(timescale?: TimeScale);
        /** Set the speed, must be more than 0 */
        setSpeed(speed: number): this;
        /** Set the pitch, must be more than 0 */
        setPitch(pitch: number): this;
        /** Set the rate, must be more than 0 */
        setRate(rate: number): this;
        /** Build the timescale filter */
        build(): TimeScale;
    }
    /** Tremolo filter builder utility */
    export class TremoloUtils {
        enabled: boolean;
        readonly tremolo: Tremolo;
        constructor(tremolo?: Tremolo);
        /** Set the frequency, must be more than 0 */
        setFrequency(frequency: number): this;
        /** Set the depth, must be between 0 to 1 */
        setDepth(depth: number): this;
        /** Build the tremolo filter */
        build(): Tremolo;
    }
    /** Vibrato filter builder utility */
    export class VibratoUtils {
        enabled: boolean;
        readonly vibrato: Vibrato;
        constructor(vibrato?: Vibrato);
        /** Set the frequency, must be between 0 and 15 */
        setFrequency(frequency: number): this;
        /** Set the depth, must be between 0 to 1 */
        setDepth(depth: number): this;
        /** Build the vibrato filter */
        build(): Vibrato;
    }
    /** Rotation filter builder utility */
    export class RotationUtils {
        enabled: boolean;
        readonly rotation: Rotation;
        constructor(rotation?: Rotation);
        /** Set the rotation speed */
        setRotationSpeed(rotationHz: number): this;
        /** Build the rotation filter */
        build(): Rotation;
    }
    /** Distortion filter builder utility */
    export class DistortionUtils {
        enabled: boolean;
        distortion: Distortion;
        constructor(distortion?: Distortion);
        /** Set the sin offset */
        setSinOffset(sinOffset: number): this;
        /** Set the sin scale */
        setSinScale(sinScale: number): this;
        /** Set the cos offset */
        setCosOffset(cosOffset: number): this;
        /** Set the cos scale */
        setCosScale(cosScale: number): this;
        /** Set the tan offset */
        setTanOffset(tanOffset: number): this;
        /** Set the tan scale */
        setTanScale(tanScale: number): this;
        /** Set the offset */
        setOffset(offset: number): this;
        /** Set the scale */
        setScale(scale: number): this;
        /** Build the distortion filter */
        build(): Distortion;
    }
    /** ChannelMix filter builder utility */
    export class ChannelMixUtils {
        enabled: boolean;
        readonly channelMix: ChannelMix;
        constructor(channelMix?: ChannelMix);
        /** Set left to left mix, must be between 0 to 1 */
        setLeftToLeft(leftToLeft: number): this;
        /** Set left to right mix, must be between 0 to 1 */
        setLeftToRight(leftToRight: number): this;
        /** Set right to left mix, must be between 0 to 1 */
        setRightToLeft(rightToLeft: number): this;
        /** Set right to right mix, must be between 0 to 1 */
        setRightToRight(rightToRight: number): this;
        /** Build the channel mix filter */
        build(): ChannelMix;
    }
    /** LowPass filter builder utility */
    export class LowPassUtils {
        enabled: boolean;
        readonly lowPass: LowPass;
        constructor(lowPass?: LowPass);
        /** Set the smoothing */
        setSmoothing(smoothing: number): this;
        /** Build the low pass filter */
        build(): LowPass;
    }
}

