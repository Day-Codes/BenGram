"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoffeeNode = void 0;
const ws_1 = __importDefault(require("ws"));
const undici_1 = require("undici");
const stream_1 = require("stream");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const constructs_1 = require("../utils/decorators/constructs");
const utils_1 = require("../utils");
const CoffeeRoutePlanner_1 = require("./CoffeeRoutePlanner");
let CoffeeNode = class CoffeeNode extends tiny_typed_emitter_1.TypedEmitter {
    constructor(lava, options) {
        super();
        this.lava = lava;
        /** Sums of http request calls since created */
        this.calls = 0;
        /** Whether the node already connected via websocket */
        this.connected = false;
        /** Whether the node is resumed from previous session */
        this.resumed = false;
        /** THe routePlanner instance to manage route planners */
        this.routePlanner = new CoffeeRoutePlanner_1.CoffeeRoutePlanner(this);
        /** The list of plugins the node has */
        this.plugins = new Map();
        this.reconnectAttempts = 1;
        this.options = {
            password: "youshallnotpass",
            secure: false,
            retryAmount: 5,
            retryDelay: 30e3,
            maxConnections: null,
            ...options
        };
        this.stats = {
            players: 0,
            playingPlayers: 0,
            uptime: 0,
            memory: {
                free: 0,
                used: 0,
                allocated: 0,
                reservable: 0
            },
            cpu: {
                cores: 0,
                systemLoad: 0,
                lavalinkLoad: 0
            },
            lastUpdated: Date.now()
        };
        this.http = new undici_1.Pool(`http${this.options.secure ? "s" : ""}://${this.options.url}`, {
            connections: this.options.maxConnections
        });
        this.requiredPlugins = this.lava.options.requiredPlugins;
        this.lava.emit("nodeCreate", this);
        this.lava.nodes.set(this.options.name, this);
    }
    /** The node name */
    get name() {
        return this.options.name;
    }
    /** The node url */
    get url() {
        return this.options.url;
    }
    /** Whether the node allow secure protocol */
    get isSecure() {
        return this.options.secure ?? false;
    }
    /**
     * Do http(s) request to the node
     */
    async request(endpoint) {
        endpoint = endpoint.replace(/^\//gm, "");
        const partials = [];
        await this.http.stream({
            path: `/${endpoint}`,
            method: "GET",
            opaque: partials,
            bodyTimeout: this.options.requestTimeout,
            headersTimeout: this.options.requestTimeout,
            headers: {
                Authorization: this.options.password
            }
        }, ({ opaque }) => new stream_1.Writable({
            defaultEncoding: "utf-8",
            write(partial, _, cb) {
                opaque.push(partial);
                cb();
            }
        }));
        this.calls++;
        return JSON.parse(partials.join(""));
    }
    /**
     * Do http(s) post request to the node
     */
    async post(endpoint, body, raw = false) {
        endpoint = endpoint.replace(/^\//gm, "");
        if (typeof body !== "undefined")
            body = JSON.stringify(body);
        const headers = {
            Authorization: this.options.password
        };
        const options = {
            path: `/${endpoint}`,
            method: "POST",
            bodyTimeout: this.options.requestTimeout,
            headersTimeout: this.options.requestTimeout,
            headers
        };
        if (typeof body === "string") {
            headers["Content-Type"] = "application/json";
            options.body = body;
        }
        const res = await this.http.request(options);
        this.calls++;
        if (raw)
            return res;
        return res.body.json();
    }
    /**
     * Connect to the node via socket
     */
    connect() {
        if (this.connected)
            return;
        this.plugins.clear();
        const headers = {
            Authorization: this.options.password,
            "Num-Shards": String(this.lava.options.shards),
            "User-Id": this.lava.clientID,
            "Client-Name": this.lava.options.clientName
        };
        if (typeof this.lava.options.resumeConfig !== "undefined") {
            headers["Resume-Key"] = this.lava.options.resumeConfig.key;
        }
        this.socket = new ws_1.default(`ws${this.options.secure ? "s" : ""}://${this.options.url}/`, { headers });
        this.socket.once("upgrade", req => {
            const resumed = req.headers["session-resumed"];
            if (resumed === "true")
                this.resumed = true;
            else
                this.resumed = false;
        });
        this.socket.once("open", this.open.bind(this));
        this.socket.once("close", this.close.bind(this));
        this.socket.on("error", this.error.bind(this));
        this.socket.on("message", this.message.bind(this));
    }
    /**
     * Destroy the node connection
     */
    destroy() {
        if (!this.connected)
            return;
        this.socket.close(1000, "destroy");
        this.socket.removeAllListeners();
        delete this.socket;
        this.reconnectAttempts = 1;
        if (this.reconnectTimeout)
            clearTimeout(this.reconnectTimeout);
        this.emit("destroy");
    }
    /**
     * Send data to the node
     */
    send(data) {
        return new Promise((resolve, reject) => {
            if (!this.connected)
                return resolve(false);
            const json = JSON.stringify(data);
            if (!data || !json.startsWith("{"))
                return resolve(false);
            this.socket?.send(json, err => {
                if (err)
                    reject(err);
                else
                    resolve(true);
            });
        });
    }
    /** Configure the resume config */
    configResume() {
        if (!this.lava.options.resumeConfig)
            return;
        void this.send({
            op: utils_1.OpCodes.ConfigResume,
            key: this.lava.options.resumeConfig.key,
            timeout: this.lava.options.resumeConfig.timeout
        });
    }
    /** Fetch the plugins the node has */
    async fetchPlugins() {
        const plugins = new Map();
        const rawPlugins = await this.request("/plugins");
        for (const plugin of rawPlugins) {
            plugins.set(plugin.name, plugin.version);
        }
        return plugins;
    }
    reconnect() {
        this.reconnectTimeout = setTimeout(() => {
            if (this.reconnectAttempts >= this.options.retryAmount) {
                this.error(new Error(`Unable to reconnect after ${this.options.retryAmount} attempts`));
                return this.destroy();
            }
            this.socket?.removeAllListeners();
            delete this.socket;
            this.emit("reconnect");
            this.connect();
            this.reconnectAttempts++;
        }, this.options.retryDelay);
    }
    async open() {
        if (this.reconnectTimeout)
            clearTimeout(this.reconnectTimeout);
        this.configResume();
        try {
            const plugins = await this.fetchPlugins();
            for (const [name, version] of plugins) {
                this.plugins.set(name, version);
            }
            // eslint-disable-next-line no-empty
        }
        catch { }
        const missingPlugins = [];
        for (const plugin of this.requiredPlugins) {
            if (!this.plugins.has(plugin))
                missingPlugins.push(plugin);
        }
        if (missingPlugins.length) {
            this.emit("missingPlugins", missingPlugins);
        }
        else {
            this.connected = true;
        }
        this.emit("connect");
    }
    close(code, reason) {
        this.connected = false;
        this.emit("disconnect", { code, reason });
        if (code !== 1000 || reason !== "destroy")
            this.reconnect();
    }
    error(error) {
        this.emit("error", error);
    }
    message(d) {
        if (Array.isArray(d))
            d = Buffer.concat(d);
        else if (d instanceof ArrayBuffer)
            d = Buffer.from(d);
        const payload = JSON.parse(d.toString());
        if (!payload.op)
            return;
        this.emit("raw", payload);
        switch (payload.op) {
            case "stats":
                this.stats = {
                    players: payload.players,
                    playingPlayers: payload.playingPlayers,
                    uptime: payload.uptime,
                    memory: payload.memory,
                    cpu: payload.cpu,
                    lastUpdated: Date.now(),
                    frameStats: payload.frameStats
                };
                break;
            case "playerUpdate":
                this.emit("playerUpdate", payload.guildId, payload.state);
                break;
            case "event":
                this.emit("event", payload);
                break;
            default:
                this.error(new Error(`Unexpected op '${payload.op}' with data: ${d.toString()}`));
        }
    }
};
CoffeeNode = __decorate([
    constructs_1.constructNode()
], CoffeeNode);
exports.CoffeeNode = CoffeeNode;
