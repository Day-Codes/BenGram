"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoffeeLava = void 0;
/* eslint-disable func-names */
/* eslint-disable prefer-arrow-callback */
const CoffeeNode_1 = require("./CoffeeNode");
const CoffeePlayer_1 = require("./CoffeePlayer");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const validators_1 = require("../utils/decorators/validators");
const constants_1 = require("../utils/constants");
const constructs_1 = require("../utils/decorators/constructs");
const CoffeeTrack_1 = require("./CoffeeTrack");
const rest_1 = require("../utils/rest");
const CoffeeQueue_1 = require("./CoffeeQueue");
/**
 * The main hub for interacting with Lavalink and using LavaCoffee
 */
let CoffeeLava = class CoffeeLava extends tiny_typed_emitter_1.TypedEmitter {
    constructor(options) {
        super();
        this.nodes = new Map();
        this.players = new Map();
        const structures = {
            Node: CoffeeNode_1.CoffeeNode,
            Player: CoffeePlayer_1.CoffeePlayer,
            Queue: CoffeeQueue_1.CoffeeQueue
        };
        if (options.structures)
            Object.assign(structures, options.structures);
        options.structures = structures;
        this.options = {
            clientName: "node-lavacoffee",
            shards: 1,
            autoPlay: true,
            defaultSearchPlatform: "yt",
            autoReplay: true,
            autoResume: true,
            balanceLoad: "system",
            requiredPlugins: [],
            ...options
        };
        delete this.options.resumeConfig;
        if (typeof options.resumeConfig !== "undefined") {
            this.configResume(options.resumeConfig);
        }
    }
    get leastUsedNode() {
        return this.sortAndGetFirstNode(this.nodes, (l, r) => l.calls - r.calls);
    }
    get leastLoadNode() {
        return this.sortAndGetFirstNode(this.nodes, (l, r) => {
            const lLoad = this.loadOf(l);
            const rLoad = this.loadOf(r);
            return lLoad - rLoad;
        });
    }
    /** Initiate the Lavalink client */
    init(clientID) {
        this.clientID = clientID;
        for (const node of this.nodes.values())
            node.connect();
    }
    /** Searches some tracks based off the URL or the `source` property */
    async search(query, requester) {
        const plugins = query.requiredPlugins ?? [];
        const node = plugins.length ? this.leastUsedFilteredNode(plugins) : this.leastUsedNode;
        const source = query.source ?? this.options.defaultSearchPlatform;
        const allowSearch = query.allowSearch ?? true;
        let search = query.query;
        if (allowSearch && !/^(?:(?:http|https):\/\/|\w+:)/.test(search))
            search = `${source}search:${search}`;
        const res = await node.request(`/loadtracks?identifier=${encodeURIComponent(search)}`);
        if (!res)
            throw new Error("Query not found");
        const result = {
            loadType: res.loadType,
            tracks: res.tracks.map(track => new CoffeeTrack_1.CoffeeTrack(track, requester))
        };
        if (res.loadType === rest_1.LoadTypes.LoadFailed) {
            result.error = res.exception;
        }
        if (res.loadType === rest_1.LoadTypes.PlaylistLoaded) {
            result.playlist = {
                name: res.playlistInfo.name,
                selectedTrack: res.playlistInfo.selectedTrack === -1
                    ? null
                    : result.tracks[res.playlistInfo.selectedTrack],
                duration: result.tracks.reduce((acc, tr) => acc + (tr.duration || 0), 0)
            };
        }
        return result;
    }
    /** Decode the base64 track into TrackData */
    async decodeTrack(track) {
        const node = this.leastUsedNode;
        const res = await node.request(`/decodetrack?track=${track}`);
        if (!res)
            throw new Error("No decoded data returned");
        const data = {
            track,
            info: res
        };
        return data;
    }
    /** Decode the base64 tracks into TracksData */
    async decodeTracks(tracks) {
        const node = this.leastUsedNode;
        const res = await node.post("/decodetracks", tracks, false);
        if (!res)
            throw new Error("No decoded data returned");
        return res;
    }
    /** Send voice data to the Lavalink server */
    updateVoiceData(p) {
        const player = this.players.get(p.d.guild_id);
        const voice = player.voice;
        if (p.t === "VOICE_SERVER_UPDATE") {
            voice.op = constants_1.OpCodes.VoiceUpdate;
            voice.guildId = p.d.guild_id;
            voice.event = p.d;
        }
        else {
            voice.sessionId = p.d.session_id;
            if (player.options.voiceID !== p.d.channel_id) {
                this.emit("playerMove", player, player.options.voiceID, p.d.channel_id);
                player.options.voiceID = p.d.channel_id;
                if (!p.d.channel_id) {
                    player.voiceState = constants_1.PlayerVoiceStates.Disconnected;
                    try {
                        if (player.state !== constants_1.PlayerStates.Paused) {
                            player.pause(true);
                            player.needResume = true;
                        }
                        // eslint-disable-next-line no-empty
                    }
                    catch { }
                }
            }
        }
        if (["op", "guildId", "event", "sessionId"].every(prop => prop in voice))
            void player.node.send(voice);
    }
    /** Configure the resume config */
    configResume(config) {
        this.options.resumeConfig = {
            timeout: 60,
            ...config
        };
        for (const node of this.nodes.values()) {
            if (node.connected) {
                node.configResume();
            }
        }
    }
    /** Create a player or return one if it already exists */
    create(options) {
        return new this.options.structures.Player(this, options);
    }
    /** Return a player or undefined if it doesn't exist */
    get(guildID) {
        return this.players.get(guildID);
    }
    /** Destroy a player if it exist */
    destroy(guildID) {
        const player = this.get(guildID);
        if (player)
            player.destroy();
    }
    /** Add a node */
    add(nodeOptions) {
        const node = new this.options.structures.Node(this, nodeOptions);
        node.removeAllListeners();
        node.on("event", payload => this.handleEvent(node, payload));
        node.on("missingPlugins", missing => this.emit("nodeMissingPlugins", node, missing));
        node.on("reconnect", () => this.emit("nodeReconnect", node));
        node.on("raw", payload => this.emit("nodeRaw", node, payload));
        node.on("error", error => this.emit("nodeError", node, error));
        node.on("destroy", () => {
            this.emit("nodeDestroy", node);
            this.nodes.delete(node.options.name);
        });
        node.on("connect", () => {
            this.emit("nodeConnect", node);
            if (this.options.autoReplay) {
                for (const player of this.players.values()) {
                    if (player.options.node === node.options.name) {
                        player.options.node = undefined;
                        player.setNode(node.options.name);
                    }
                }
            }
        });
        node.on("disconnect", reason => {
            this.emit("nodeDisconnect", node, reason);
            if (this.options.autoReplay) {
                for (const player of this.players.values()) {
                    if (player.options.node === node.options.name) {
                        try {
                            const requiredPlugins = player.options.requiredPlugins;
                            player.setNode(requiredPlugins.length
                                ? this.leastLoadFilteredNode(requiredPlugins).options.name
                                : this.leastLoadNode.options.name);
                        }
                        catch (error) {
                            this.emit("replayError", player, error);
                        }
                    }
                }
            }
        });
        node.on("playerUpdate", (guildID, state) => {
            const player = this.players.get(guildID);
            if (!player) {
                if (node.resumed) {
                    this.options.resumeConfig?.handle(this, guildID, player => {
                        player.lastUpdated = state.time;
                        player.position = state.position;
                        player.voiceConnected = state.connected;
                    });
                }
                return;
            }
            player.lastUpdated = state.time;
            player.position = state.position;
            player.voiceConnected = state.connected;
        });
        if (this.clientID)
            node.connect();
    }
    leastUsedFilteredNode(plugins) {
        const nodes = this.filterPlugins(plugins);
        return this.sortAndGetFirstNode(nodes, (l, r) => l.calls - r.calls);
    }
    leastLoadFilteredNode(plugins) {
        const nodes = this.filterPlugins(plugins);
        return this.sortAndGetFirstNode(nodes, (l, r) => {
            const lLoad = this.loadOf(l);
            const rLoad = this.loadOf(r);
            return lLoad - rLoad;
        });
    }
    handleEvent(node, event) {
        if (!event.guildId)
            return;
        const player = this.get(event.guildId);
        if (!player)
            return;
        const track = player.queue.current;
        const type = event.type;
        switch (type) {
            case constants_1.EventTypes.TrackStart:
                {
                    player.state = constants_1.PlayerStates.Playing;
                    if (player.replaying) {
                        player.replaying = false;
                        return;
                    }
                    this.emit("trackStart", player, track, event);
                    if (!player.queue.previous)
                        this.emit("queueStart", player, track, event);
                }
                break;
            case constants_1.EventTypes.TrackEnd:
                {
                    if (event.reason === "CLEANUP")
                        return;
                    this.emit("trackEnd", player, track, event);
                    if (event.reason === "REPLACED")
                        return;
                    if (!player.queue.length && player.loop === constants_1.LoopMode.None) {
                        this.emit("queueEnd", player, track, event);
                    }
                    if (this.options.autoPlay)
                        void player.play(player.playOptions);
                }
                break;
            case constants_1.EventTypes.TrackStuck:
                {
                    this.emit("trackStuck", player, track, event);
                    if (!player.queue.length && player.loop === constants_1.LoopMode.None) {
                        this.emit("queueEnd", player, track, event);
                    }
                    if (this.options.autoPlay)
                        void player.play(player.playOptions);
                }
                break;
            case constants_1.EventTypes.TrackException:
                {
                    // Replay
                    if (event.exception.message === "The track was unexpectedly terminated.")
                        return;
                    this.emit("trackError", player, track, event);
                    if (!player.queue.length && player.loop === constants_1.LoopMode.None) {
                        this.emit("queueEnd", player, track, event);
                    }
                    if (this.options.autoPlay)
                        void player.play(player.playOptions);
                }
                break;
            case constants_1.EventTypes.WebSocketClosed:
                if (!player.voiceConnected && player.voiceState === constants_1.PlayerVoiceStates.Connected) {
                    if (this.options.autoResume &&
                        player.options.voiceID)
                        player.connect();
                    else
                        player.disconnect();
                }
                this.emit("socketClosed", player, event);
                break;
            default:
                this.emit("nodeError", node, new Error(`Node#event unknown event type '${type}'`));
        }
    }
    sortAndGetFirstNode(unsortedNodes, sortFunc) {
        const nodes = new Map();
        for (const [id, node] of unsortedNodes) {
            if (node.connected)
                nodes.set(id, node);
        }
        const entries = [...nodes.entries()];
        entries.sort(([, a], [, b]) => sortFunc(a, b));
        nodes.clear();
        for (const [id, node] of entries) {
            nodes.set(id, node);
        }
        return nodes.values().next().value;
    }
    filterPlugins(plugins) {
        const nodes = new Map();
        nodeLoop: for (const [id, node] of this.nodes) {
            for (const plugin of plugins) {
                if (!node.plugins.has(plugin))
                    continue nodeLoop;
            }
            nodes.set(id, node);
        }
        return nodes;
    }
    loadOf(node) {
        return node.stats.cpu
            ? ((this.options.balanceLoad === "system"
                ? node.stats.cpu.systemLoad
                : node.stats.cpu.lavalinkLoad) / node.stats.cpu.cores) * 100
            : 0;
    }
};
__decorate([
    validators_1.check(function (method, clientID) {
        if (this.clientID)
            return;
        if (typeof clientID !== "string" || !clientID)
            throw new TypeError("Parameter 'clientID' must be present and be a non-empty string");
        return method(clientID);
    })
], CoffeeLava.prototype, "init", null);
__decorate([
    validators_1.check(function (method, query, requester) {
        if (typeof query !== "object" ||
            query === null)
            throw new TypeError("Parameter 'query' must be present and be an object");
        const plugins = query.requiredPlugins ?? [];
        const node = plugins.length ? this.leastUsedFilteredNode(plugins) : this.leastUsedNode;
        if (!node || !node.connected)
            throw new Error("No node is available currently");
        return method(query, requester);
    })
], CoffeeLava.prototype, "search", null);
__decorate([
    validators_1.check(function (method, track) {
        if (typeof track !== "string" || !track)
            throw new TypeError("Parameter 'track' must be present and be a non-empty string");
        const node = this.leastUsedNode;
        if (!node || !node.connected)
            throw new Error("No node is available currently");
        return method(track);
    })
], CoffeeLava.prototype, "decodeTrack", null);
__decorate([
    validators_1.check(function (method, tracks) {
        if (!Array.isArray(tracks))
            throw new TypeError("Parameter 'tracks' must be present and be a non-empty-string array");
        const node = this.leastUsedNode;
        if (!node || !node.connected)
            throw new Error("No node is available currently");
        return method(tracks);
    })
], CoffeeLava.prototype, "decodeTracks", null);
__decorate([
    validators_1.check(function (method, p) {
        if (!p ||
            !["VOICE_SERVER_UPDATE", "VOICE_STATE_UPDATE"].includes(p.t || ""))
            return;
        if (!this.players.has(p.d.guild_id))
            return;
        if (p.t === "VOICE_STATE_UPDATE" &&
            p.d.user_id !== this.clientID)
            return;
        return method(p);
    })
], CoffeeLava.prototype, "updateVoiceData", null);
__decorate([
    validators_1.check(function (method, config) {
        if (typeof config !== "object" ||
            config === null)
            throw new TypeError("Parameters 'config' must be present and be an object");
        if (typeof config.key !== "string" || !config.key)
            throw new TypeError("Config 'key' must be present and be a non-empty string");
        if (typeof config.handle !== "function")
            throw new TypeError("Config 'handle' must be present and be a function");
        if (typeof config.timeout !== "undefined" &&
            (typeof config.timeout !== "number" || isNaN(config.timeout)))
            throw new TypeError("Config 'timeout' must be a number");
        return method(config);
    })
], CoffeeLava.prototype, "configResume", null);
CoffeeLava = __decorate([
    constructs_1.constructCoffee()
], CoffeeLava);
exports.CoffeeLava = CoffeeLava;
