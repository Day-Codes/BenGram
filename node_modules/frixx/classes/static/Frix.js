"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Player = void 0;
const discord_js_1 = require("discord.js");
const voice_1 = require("@discordjs/voice");
const time_1 = __importStar(require("@myno_21/time"));
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const play_dl_1 = __importDefault(require("play-dl"));
const isAUri_1 = __importDefault(require("../../utilities/isAUri"));
const msToStringfyDate_1 = __importDefault(require("../../utilities/msToStringfyDate"));
const detectUri_js_1 = __importDefault(require("../../detectors/detectUri.js"));
const getTrackResponse_js_1 = __importDefault(require("../../functions/fetches/getTrackResponse.js"));
const grabber_js_1 = __importDefault(require("../../_grabber/grabber.js"));
const ytdl_core_1 = __importDefault(require("ytdl-core"));
const searchForATrack_js_1 = __importDefault(require("../../functions/fetches/searchForATrack.js"));
const findRelatedTrack_js_1 = __importDefault(require("../../extras/findRelatedTrack.js"));
const suffixQueue_1 = __importDefault(require("../resolver/suffixQueue"));
const relatedTrack_1 = require("../resolver/relatedTrack");
const playlists_1 = __importDefault(require("../../core/playlists"));
const queue = new discord_js_1.Collection();
/**
 * @since Sunday, 11 December 2022
 * @description The player as of now only supports YouTube and Spotify as the main source to play the music. The player requires a client (Mandatory). You have to instantiate a client.
 */
class Player extends tiny_typed_emitter_1.TypedEmitter {
    /**
     * @param {Client} client
     * (Mandatory)
     */
    constructor(client) {
        super();
        /**
         * @default
         * @module *frix*
         * @author *TrishCX*
         * @function *play*
         *@description The player as of now only supports YouTube and Spotify as the main playing source.
         * @since Sunday, 11 December 2022
         * @param guild The "Guild" property from the discord.js.
         * @param query The query to play. This can be whether a uri/url or a simple search term.
         * @param voiceChannelId The voice channel id.
         * @param type The type, it can be whether a Message or ChatInputCommandInteraction.
         * @param member The GuildMember field from the discord.js itself.
         * @example  - *__TypeScript__*
         ```typescript
        const query = interaction.options.getString("query");
          await interaction.deferReply();
          const member = await interaction.guild?.members.cache.get(
            interaction.user.id
          )!.voice;
          const m = await interaction.guild?.members.cache.get(interaction.user.id);
          const guild = interaction?.guild!;
          await player?.play!(
            interaction.guild!,
            `${query}`,
            `${member?.channel?.id}`,
            m!,
            interaction,
          );
         ```
          - *__JavaScript__*
            ```js
            const query = interaction.options.getString("query");
              await interaction.deferReply();
              const member = await interaction.guild?.members.cache.get(interaction.user.id).voice;
              const m = await interaction.guild?.members.cache.get(interaction.user.id);
              const guild = interaction?.guild;
              await player?.play(interaction.guild, `${query}`, `${member?.channel?.id}`, interaction, m);
            ```
         *
         */
        this.play = async (guild, query, voiceChannelId, member, type) => {
            if (!member?.voice.channel)
                throw new Error(`Connect to a voice channel.`);
            if (type?.guild?.members?.me?.voice?.channel &&
                member.voice.channelId !== type.guild.members.me.voice.channelId)
                throw new EvalError("You need to be in the same voice channel as the client.");
            if (!type?.guild?.members.me?.permissions.has(discord_js_1.PermissionsBitField.Flags.Connect))
                throw new Error("The client doesn't have the permission to connect to the voice channel");
            if (!query || !query.length)
                return new Error(`No query provided.`);
            const is_uri = (0, isAUri_1.default)(query);
            const getQueue = (await queue.get(guild?.id));
            const array = [];
            const previousSongsArray = [];
            this.connection = await (0, voice_1.joinVoiceChannel)({
                channelId: voiceChannelId,
                guildId: guild?.id,
                selfDeaf: false,
                adapterCreator: guild?.voiceAdapterCreator,
            });
            const client = guild.members.me?.client;
            client?.on("voiceStateUpdate", (oldState, newState) => {
                if (oldState?.member?.id === guild?.members?.me?.id) {
                    if (newState.channelId === null) {
                        this.emit("leftVoiceChannel", oldState.channel);
                    }
                }
            });
            this.emit("voiceConnected", this.connection);
            if (is_uri === true) {
                const source = await (0, detectUri_js_1.default)(query);
                if (source === "Invalid Source.")
                    throw new Error(`Invalid source provided. Choose between Spotify | YouTube`);
                if (source === "spotify") {
                    const response = await (0, getTrackResponse_js_1.default)(query);
                    const finalLook = await (0, grabber_js_1.default)(response.name, response.artists?.[0].name);
                    if (getQueue?.tracks?.length > 0) {
                        const _q = queue?.get(guild?.id);
                        await _q.tracks?.push({
                            author: response.artists?.[0].name,
                            spotifyDuration: (0, msToStringfyDate_1.default)(response?.duration),
                            spotifyThumbnail: response.coverArt?.sources?.[0].url,
                            spotifyTitle: response.title,
                            spotifyURL: response.external_urls?.spotify,
                            youtubeDuration: finalLook.durationFormatted,
                            youtubeThumbnail: finalLook.thumbnail?.url,
                            youtubeTitle: finalLook.title,
                            youtubeURL: finalLook.url,
                            user: member,
                            trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                            durationSeconds: finalLook.duration,
                        });
                        this.emit("trackAdded", type, {
                            author: response.artists?.[0].name,
                            spotifyDuration: (0, msToStringfyDate_1.default)(response?.duration),
                            spotifyThumbnail: response.coverArt?.sources?.[0].url,
                            spotifyTitle: response.title,
                            spotifyURL: response.external_urls?.spotify,
                            youtubeDuration: finalLook.durationFormatted,
                            youtubeThumbnail: finalLook.thumbnail?.url,
                            youtubeTitle: finalLook.title,
                            youtubeURL: finalLook.url,
                            durationSeconds: finalLook.duration,
                            trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                            user: member,
                        }, _q);
                    }
                    else {
                        const constructorOfQueue = {
                            connection: this.connection,
                            voiceChannelId: voiceChannelId,
                            type,
                            tracks: array,
                            previousSongs: previousSongsArray,
                        };
                        this.stream = await play_dl_1.default.stream(finalLook.url);
                        this.resource = (0, voice_1.createAudioResource)(this.stream.stream, {
                            inputType: this.stream.type,
                            inlineVolume: true,
                        });
                        this.player = await (0, voice_1.createAudioPlayer)({
                            behaviors: {
                                noSubscriber: voice_1.NoSubscriberBehavior.Play,
                            },
                        });
                        constructorOfQueue.tracks.push({
                            author: response.artists?.[0].name,
                            spotifyDuration: (0, msToStringfyDate_1.default)(response?.duration),
                            spotifyThumbnail: response.coverArt?.sources?.[0].url,
                            spotifyTitle: response.title,
                            spotifyURL: response.external_urls?.spotify,
                            youtubeDuration: finalLook.durationFormatted,
                            youtubeThumbnail: finalLook.thumbnail?.url,
                            youtubeTitle: finalLook.title,
                            youtubeURL: finalLook.url,
                            user: member,
                            trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                            durationSeconds: finalLook.duration,
                        });
                        this.emit("trackNowPlaying", type, {
                            author: response.artists?.[0].name,
                            spotifyDuration: (0, msToStringfyDate_1.default)(response?.duration),
                            spotifyThumbnail: response.coverArt?.sources?.[0].url,
                            spotifyTitle: response.title,
                            spotifyURL: response.external_urls?.spotify,
                            youtubeDuration: finalLook.durationFormatted,
                            youtubeThumbnail: finalLook.thumbnail?.url,
                            youtubeTitle: finalLook.title,
                            youtubeURL: finalLook.url,
                            user: member,
                            trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                            durationSeconds: finalLook.duration,
                        });
                        await queue.set(guild?.id, constructorOfQueue);
                        this.player.play(this.resource);
                        this.isPlaying = true;
                        this.connection.subscribe(this.player);
                        this.player.on(voice_1.AudioPlayerStatus.Idle, async () => {
                            const _q = queue?.get(guild?.id);
                            if (this.loopEnabled === true) {
                                let stream = await play_dl_1.default.stream(`${_q.tracks?.[0].youtubeURL}`);
                                let resource = (0, voice_1.createAudioResource)(stream.stream, {
                                    inlineVolume: true,
                                    inputType: stream.type,
                                });
                                this.player?.play(resource);
                                this.connection?.subscribe(this.player);
                                this.emit("trackNowPlaying", type, _q.tracks?.[0]);
                            }
                            else if (this.isAutoPlayEnabled === true) {
                                this.emit("trackEnd", type, _q);
                                this.isPaused = true;
                                this.isPlaying = false;
                                const currentSong = _q.tracks?.[0];
                                const _song = await (await ytdl_core_1.default.getInfo(`${currentSong?.youtubeURL}`)).related_videos[0];
                                const spot = await (0, searchForATrack_js_1.default)(_song.title);
                                _q.tracks?.push({
                                    author: spot.album?.artists?.[0].name,
                                    durationSeconds: _song.length_seconds,
                                    spotifyDuration: (0, msToStringfyDate_1.default)(spot.duration_ms),
                                    spotifyThumbnail: spot.album?.images?.[0].url,
                                    spotifyTitle: spot.name,
                                    spotifyURL: spot.external_urls?.spotify,
                                    trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                                    user: member,
                                    youtubeDuration: (0, time_1.secondsToDuration)(_song.length_seconds),
                                    youtubeThumbnail: _song.thumbnails[_song.thumbnails.length - 1].url,
                                    youtubeTitle: _song.title,
                                    youtubeURL: `https://www.youtube.com/watch?v=${_song.id}`,
                                });
                                _q.previousSongs?.push(currentSong);
                                _q.tracks?.shift();
                                this.stream = await play_dl_1.default.stream(`${_q?.tracks[0]?.youtubeURL}`);
                                this.resource = (0, voice_1.createAudioResource)(this.stream?.stream, {
                                    inputType: this.stream?.type,
                                    inlineVolume: true,
                                });
                                this.player = (0, voice_1.createAudioPlayer)({
                                    behaviors: {
                                        noSubscriber: voice_1.NoSubscriberBehavior.Play,
                                    },
                                });
                                this.player.play(this.resource);
                                this.connection?.subscribe(this.player);
                                this.isPlaying = true;
                                this.isPaused = false;
                                this.emit("trackNowPlaying", type, _q?.tracks[0]);
                            }
                            else {
                                this.emit("trackEnd", type, _q);
                                if (!_q)
                                    return;
                                _q.previousSongs?.push(_q.tracks?.[0]);
                                _q.tracks?.shift();
                                if (_q?.tracks?.length < 1) {
                                    this.isPlaying = false;
                                    this.isPaused = true;
                                    this.emit("emptyQueue", type, _q);
                                }
                                else {
                                    this.stream = await play_dl_1.default.stream(`${_q?.tracks[0]?.youtubeURL}`);
                                    this.resource = (0, voice_1.createAudioResource)(this.stream?.stream, {
                                        inputType: this.stream?.type,
                                        inlineVolume: true,
                                    });
                                    this.player = (0, voice_1.createAudioPlayer)({
                                        behaviors: {
                                            noSubscriber: voice_1.NoSubscriberBehavior.Play,
                                        },
                                    });
                                    this.player.play(this.resource);
                                    this.connection?.subscribe(this.player);
                                    this.isPlaying = true;
                                    this.isPaused = false;
                                    this.emit("trackNowPlaying", type, _q?.tracks[0]);
                                }
                            }
                        });
                    }
                }
                else if (source === "youtube") {
                    const finalLook = await (await ytdl_core_1.default.getInfo(query)).videoDetails;
                    const spotifySearch = await (0, searchForATrack_js_1.default)(`${finalLook.title}`);
                    if (getQueue?.tracks?.length > 0) {
                        await getQueue?.tracks?.push({
                            author: spotifySearch.album?.artists[0].name || finalLook.author.name,
                            spotifyDuration: (0, msToStringfyDate_1.default)(spotifySearch.duration_ms) || undefined,
                            spotifyThumbnail: spotifySearch.album?.images?.[0].url || undefined,
                            spotifyTitle: spotifySearch.name || undefined,
                            spotifyURL: spotifySearch.external_urls?.spotify || undefined,
                            youtubeDuration: time_1.default.secondsToDuration(Number(finalLook.lengthSeconds)),
                            youtubeThumbnail: finalLook.thumbnails[finalLook.thumbnails.length - 1].url,
                            youtubeTitle: finalLook.title,
                            youtubeURL: finalLook.video_url,
                            user: member,
                            trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                            durationSeconds: Number(finalLook.lengthSeconds),
                        });
                        // Have to emit a event
                        this.emit("trackAdded", type, {
                            author: spotifySearch.album?.artists[0].name || finalLook.author.name,
                            spotifyDuration: (0, msToStringfyDate_1.default)(spotifySearch.duration_ms) || undefined,
                            spotifyThumbnail: spotifySearch.album?.images?.[0].url || undefined,
                            spotifyTitle: spotifySearch.name || undefined,
                            spotifyURL: spotifySearch.external_urls?.spotify || undefined,
                            youtubeDuration: time_1.default.secondsToDuration(Number(finalLook.lengthSeconds)),
                            youtubeThumbnail: finalLook.thumbnails[finalLook.thumbnails.length - 1].url,
                            youtubeTitle: finalLook.title,
                            youtubeURL: finalLook.video_url,
                            user: member,
                            trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                            durationSeconds: Number(finalLook.lengthSeconds),
                        }, getQueue);
                    }
                    else {
                        const constructorOfQueue = {
                            connection: this.connection,
                            voiceChannelId,
                            type,
                            tracks: array,
                            previousSongs: previousSongsArray,
                        };
                        this.stream = await play_dl_1.default.stream(finalLook.video_url);
                        this.resource = await (0, voice_1.createAudioResource)(this.stream.stream, {
                            inputType: this.stream.type,
                            inlineVolume: true,
                        });
                        this.player = await (0, voice_1.createAudioPlayer)({
                            behaviors: {
                                noSubscriber: voice_1.NoSubscriberBehavior.Play,
                            },
                        });
                        constructorOfQueue.tracks.push({
                            author: spotifySearch.album?.artists[0].name || finalLook.author.name,
                            spotifyDuration: (0, msToStringfyDate_1.default)(spotifySearch.duration_ms) || undefined,
                            spotifyThumbnail: spotifySearch.album?.images?.[0].url || undefined,
                            spotifyTitle: spotifySearch.name || undefined,
                            spotifyURL: spotifySearch.external_urls?.spotify || undefined,
                            youtubeDuration: time_1.default.secondsToDuration(Number(finalLook.lengthSeconds)),
                            youtubeThumbnail: finalLook.thumbnails[finalLook.thumbnails.length - 1].url,
                            youtubeTitle: finalLook.title,
                            youtubeURL: finalLook.video_url,
                            user: member,
                            trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                            durationSeconds: Number(finalLook.lengthSeconds),
                        });
                        this.emit("trackNowPlaying", type, {
                            author: spotifySearch.album?.artists[0].name || finalLook.author.name,
                            spotifyDuration: (0, msToStringfyDate_1.default)(spotifySearch.duration_ms) || undefined,
                            spotifyThumbnail: spotifySearch.album?.images?.[0].url || undefined,
                            spotifyTitle: spotifySearch.name || undefined,
                            spotifyURL: spotifySearch.external_urls?.spotify || undefined,
                            youtubeDuration: time_1.default.secondsToDuration(Number(finalLook.lengthSeconds)),
                            youtubeThumbnail: finalLook.thumbnails[finalLook.thumbnails.length - 1].url,
                            youtubeTitle: finalLook.title,
                            youtubeURL: finalLook.video_url,
                            user: member,
                            trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                            durationSeconds: Number(finalLook.lengthSeconds),
                        });
                        await queue.set(guild?.id, constructorOfQueue);
                        this.player.play(this.resource);
                        this.connection.subscribe(this.player);
                        this.isPlaying = true;
                        this.isPaused = false;
                        this.player.on(voice_1.AudioPlayerStatus?.Idle, async () => {
                            const _q = queue.get(guild?.id);
                            if (this.loopEnabled === true) {
                                let stream = await play_dl_1.default.stream(`${_q.tracks?.[0].youtubeURL}`);
                                let resource = (0, voice_1.createAudioResource)(stream.stream, {
                                    inlineVolume: true,
                                    inputType: stream.type,
                                });
                                this.player?.play(resource);
                                this.connection?.subscribe(this.player);
                                this.emit("trackNowPlaying", type, _q.tracks?.[0]);
                            }
                            else if (this.isAutoPlayEnabled === true) {
                                this.emit("trackEnd", type, _q);
                                this.isPaused = true;
                                this.isPlaying = false;
                                const currentSong = _q.tracks?.[0];
                                const _song = await (await ytdl_core_1.default.getInfo(`${currentSong?.youtubeURL}`)).related_videos[0];
                                const spot = await (0, searchForATrack_js_1.default)(_song.title);
                                _q.tracks?.push({
                                    author: spot.album?.artists?.[0].name,
                                    durationSeconds: _song.length_seconds,
                                    spotifyDuration: (0, msToStringfyDate_1.default)(spot.duration_ms),
                                    spotifyThumbnail: spot.album?.images?.[0].url,
                                    spotifyTitle: spot.name,
                                    spotifyURL: spot.external_urls?.spotify,
                                    trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                                    user: member,
                                    youtubeDuration: (0, time_1.secondsToDuration)(_song.length_seconds),
                                    youtubeThumbnail: _song.thumbnails[_song.thumbnails.length - 1].url,
                                    youtubeTitle: _song.title,
                                    youtubeURL: `https://www.youtube.com/watch?v=${_song.id}`,
                                });
                                if (!_q)
                                    return;
                                _q.previousSongs?.push(currentSong);
                                _q.tracks?.shift();
                                this.stream = await play_dl_1.default.stream(`${_q?.tracks[0]?.youtubeURL}`);
                                this.resource = (0, voice_1.createAudioResource)(this.stream?.stream, {
                                    inputType: this.stream?.type,
                                    inlineVolume: true,
                                });
                                this.player = (0, voice_1.createAudioPlayer)({
                                    behaviors: {
                                        noSubscriber: voice_1.NoSubscriberBehavior.Play,
                                    },
                                });
                                this.player.play(this.resource);
                                this.connection?.subscribe(this.player);
                                this.isPlaying = true;
                                this.isPaused = false;
                                this.emit("trackNowPlaying", type, _q?.tracks[0]);
                            }
                            else {
                                this.emit("trackEnd", type, _q);
                                if (!_q)
                                    return;
                                _q.previousSongs?.push(_q.tracks?.[0]);
                                _q.tracks?.shift();
                                if (_q?.tracks?.length < 1) {
                                    this.emit("emptyQueue", type, _q);
                                    this.isPlaying = false;
                                    this.isPaused = true;
                                }
                                else {
                                    this.stream = await play_dl_1.default.stream(`${_q?.tracks[0]?.youtubeURL}`);
                                    this.resource = (0, voice_1.createAudioResource)(this.stream?.stream, {
                                        inputType: this.stream?.type,
                                        inlineVolume: true,
                                    });
                                    this.player = (0, voice_1.createAudioPlayer)({
                                        behaviors: {
                                            noSubscriber: voice_1.NoSubscriberBehavior.Play,
                                        },
                                    });
                                    this.player.play(this.resource);
                                    this.connection?.subscribe(this.player);
                                    this.emit("trackNowPlaying", type, _q.tracks?.[0]);
                                    this.isPlaying = true;
                                    this.isPaused = false;
                                }
                            }
                        });
                    }
                }
            }
            else {
                const getQueue = (await queue?.get(guild?.id));
                const spotifyResults = await (0, searchForATrack_js_1.default)(`${query}` || query);
                const __youtubeResults = await (0, grabber_js_1.default)(`${spotifyResults.name}`, `${spotifyResults?.album?.artists[0]?.name}`);
                if (getQueue?.tracks?.length > 0) {
                    await getQueue.tracks?.push({
                        author: spotifyResults.album?.artists[0].name,
                        spotifyDuration: (0, msToStringfyDate_1.default)(spotifyResults.duration_ms) || undefined,
                        spotifyThumbnail: spotifyResults.album?.images[0].url,
                        spotifyTitle: spotifyResults.name,
                        spotifyURL: spotifyResults.external_urls?.spotify,
                        youtubeDuration: __youtubeResults.durationFormatted,
                        youtubeThumbnail: __youtubeResults.thumbnail?.url,
                        youtubeTitle: __youtubeResults.title,
                        youtubeURL: __youtubeResults.url,
                        user: member,
                        trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                        durationSeconds: __youtubeResults.duration,
                    });
                    this.emit("trackAdded", type, {
                        author: spotifyResults.album?.artists[0].name,
                        spotifyDuration: (0, msToStringfyDate_1.default)(spotifyResults.duration_ms) || undefined,
                        spotifyThumbnail: spotifyResults.album?.images[0].url,
                        spotifyTitle: spotifyResults.name,
                        spotifyURL: spotifyResults.external_urls?.spotify,
                        youtubeDuration: __youtubeResults.durationFormatted,
                        youtubeThumbnail: __youtubeResults.thumbnail?.url,
                        youtubeTitle: __youtubeResults.title,
                        youtubeURL: __youtubeResults.url,
                    }, getQueue);
                }
                else {
                    const constructorOfQueue = {
                        connection: this.connection,
                        voiceChannelId,
                        type,
                        tracks: array,
                        previousSongs: previousSongsArray,
                    };
                    this.stream = await play_dl_1.default.stream(__youtubeResults.url);
                    this.resource = await (0, voice_1.createAudioResource)(this.stream.stream, {
                        inputType: this.stream?.type,
                        inlineVolume: true,
                    });
                    this.player = await (0, voice_1.createAudioPlayer)({
                        behaviors: {
                            noSubscriber: voice_1.NoSubscriberBehavior.Play,
                        },
                    });
                    constructorOfQueue.tracks.push({
                        author: spotifyResults.album?.artists[0].name,
                        spotifyDuration: (0, msToStringfyDate_1.default)(spotifyResults.duration_ms) || undefined,
                        spotifyThumbnail: spotifyResults.album?.images[0].url,
                        spotifyTitle: spotifyResults.name,
                        spotifyURL: spotifyResults.external_urls?.spotify,
                        youtubeDuration: __youtubeResults.durationFormatted,
                        youtubeThumbnail: __youtubeResults.thumbnail?.url,
                        youtubeTitle: __youtubeResults.title,
                        youtubeURL: __youtubeResults.url,
                        user: member,
                        trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                        durationSeconds: __youtubeResults.duration,
                    });
                    this.emit("trackNowPlaying", type, {
                        author: spotifyResults.album?.artists[0].name,
                        spotifyDuration: (0, msToStringfyDate_1.default)(spotifyResults.duration_ms) || undefined,
                        spotifyThumbnail: spotifyResults.album?.images[0].url,
                        spotifyTitle: spotifyResults.name,
                        spotifyURL: spotifyResults.external_urls?.spotify,
                        youtubeDuration: __youtubeResults.durationFormatted,
                        youtubeThumbnail: __youtubeResults.thumbnail?.url,
                        youtubeTitle: __youtubeResults.title,
                        youtubeURL: __youtubeResults.url,
                    });
                    await queue.set(guild?.id, constructorOfQueue);
                    this.player.play(this.resource);
                    this.connection?.subscribe(this.player);
                    this.isPlaying = true;
                    this.isPaused = false;
                    this.player.on(voice_1.AudioPlayerStatus.Idle, async () => {
                        const _q = queue?.get(guild?.id);
                        if (this.loopEnabled === true) {
                            let stream = await play_dl_1.default.stream(`${_q.tracks?.[0].youtubeURL}`);
                            let resource = (0, voice_1.createAudioResource)(stream.stream, {
                                inlineVolume: true,
                                inputType: stream.type,
                            });
                            this.player?.play(resource);
                            this.connection?.subscribe(this.player);
                            this.emit("trackNowPlaying", type, _q.tracks?.[0]);
                        }
                        else if (this.isAutoPlayEnabled === true) {
                            this.emit("trackEnd", type, _q);
                            this.isPaused = true;
                            this.isPlaying = false;
                            const currentSong = _q.tracks?.[0];
                            const _song = await (await ytdl_core_1.default.getInfo(`${currentSong?.youtubeURL}`)).related_videos[0];
                            const spot = await (0, searchForATrack_js_1.default)(_song.title);
                            _q.tracks?.push({
                                author: spot.album?.artists?.[0].name,
                                durationSeconds: _song.length_seconds,
                                spotifyDuration: (0, msToStringfyDate_1.default)(spot.duration_ms),
                                spotifyThumbnail: spot.album?.images?.[0].url,
                                spotifyTitle: spot.name,
                                spotifyURL: spot.external_urls?.spotify,
                                trackAddedOn: `${time_1.default.getCurrentFormattedTime()}`,
                                user: member,
                                youtubeDuration: (0, time_1.secondsToDuration)(_song.length_seconds),
                                youtubeThumbnail: _song.thumbnails[_song.thumbnails.length - 1].url,
                                youtubeTitle: _song.title,
                                youtubeURL: `https://www.youtube.com/watch?v=${_song.id}`,
                            });
                            _q.previousSongs?.push(currentSong);
                            _q.tracks?.shift();
                            this.stream = await play_dl_1.default.stream(`${_q?.tracks[0]?.youtubeURL}`);
                            this.resource = (0, voice_1.createAudioResource)(this.stream?.stream, {
                                inputType: this.stream?.type,
                                inlineVolume: true,
                            });
                            this.player = (0, voice_1.createAudioPlayer)({
                                behaviors: {
                                    noSubscriber: voice_1.NoSubscriberBehavior.Play,
                                },
                            });
                            this.player.play(this.resource);
                            this.connection?.subscribe(this.player);
                            this.isPlaying = true;
                            this.isPaused = false;
                            this.emit("trackNowPlaying", type, _q?.tracks[0]);
                        }
                        else {
                            this.emit("trackEnd", type, _q);
                            if (!_q)
                                return;
                            _q.previousSongs?.push(_q.tracks?.[0]);
                            _q.tracks?.shift();
                            if (_q?.tracks?.length < 1) {
                                this.isPlaying = false;
                                this.isPaused = true;
                                this.emit("emptyQueue", type, _q);
                            }
                            else {
                                this.stream = await play_dl_1.default.stream(`${_q?.tracks[0]?.youtubeURL}`);
                                this.resource = (0, voice_1.createAudioResource)(this.stream?.stream, {
                                    inputType: this.stream?.type,
                                    inlineVolume: true,
                                });
                                this.player = (0, voice_1.createAudioPlayer)({
                                    behaviors: {
                                        noSubscriber: voice_1.NoSubscriberBehavior.Play,
                                    },
                                });
                                this.player.play(this.resource);
                                this.connection?.subscribe(this.player);
                                this.isPlaying = true;
                                this.isPaused = false;
                                this.emit("trackNowPlaying", type, _q?.tracks[0]);
                            }
                        }
                    });
                }
            }
        };
        /**
         *@default
        @description *Toggles the loop mode.*
         * @param guild The guild property - (Mandatory)
         *
         */
        this.toggleLoop = async (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _q = queue?.get(guild?.id);
            if (!_q || _q === undefined || _q === null)
                throw Error("The queue is empty.");
            return (this.loopEnabled = true
                ? (this.loopEnabled = false)
                : (this.loopEnabled = true));
        };
        /**
         *@default
          @description *Turns the loop mode to on.*
         * @param guild The guild property - (Mandatory)
          @deprecated
         */
        this.loopAdd = (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _q = queue?.get(guild?.id);
            if (!_q || _q === undefined || _q === null)
                throw Error("The queue is empty.");
            return (this.loopEnabled = true);
        };
        /**
         *@default
          @description *Turns the loop mode to off.*
         * @param guild The guild property - (Mandatory)
          @deprecated
         */
        this.loopRemove = (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _q = queue?.get(guild?.id);
            if (!_q || _q === undefined || _q === null)
                throw Error("The queue is empty.");
            return (this.loopEnabled = false);
        };
        /**
         * @default
         * @description *Pauses the current playing track*
         * @throws *{Error}*
         * @param guild The guild property - (Mandatory)
         */
        this.pause = (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _q = queue?.get(guild?.id);
            if (!_q || _q === undefined || _q === null)
                throw Error("The queue is empty.");
            this.isPaused = true;
            this.isPlaying = false;
            return this.player?.pause() === true
                ? Error(`The played is already paused.`)
                : this.player?.pause();
        };
        /**
         *@default
        @description *Seeks/Forwards the songs to xyz seconds.*
         * @param guild The guild property - (Mandatory)
         * @param secondsToSeek *Seconds to seek - (Mandatory)*
         */
        this.seek = async (guild, secondsToSeek) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            if (!secondsToSeek)
                throw Error(`You need to provide the duration in seconds.`);
            if (typeof secondsToSeek !== "number")
                throw EvalError(`The duration needs to be a number.`);
            const _q = (await queue?.get(guild?.id));
            if (!_q || _q === undefined || _q === null)
                throw Error("The queue is empty.");
            const seconds = _q.tracks?.[0].durationSeconds;
            if (secondsToSeek > seconds)
                throw EvalError(`The actual duration of the current playing track in seconds is ${seconds}`);
            var _seconds = ((this.resource?.playbackDuration % 60000) / 1000).toFixed(0);
            const track = await play_dl_1.default.stream(_q.tracks?.[0].youtubeURL, {
                seek: Number(_seconds) + secondsToSeek,
            });
            const resource = await (0, voice_1.createAudioResource)(track.stream, {
                inlineVolume: true,
                inputType: track?.type,
            });
            const player = await (0, voice_1.createAudioPlayer)({
                behaviors: {
                    noSubscriber: voice_1.NoSubscriberBehavior.Play,
                },
            });
            player.play(resource);
            this.connection?.subscribe(player);
        };
        /**
         * @default
         * @description *Resumes the paused track.*
         * @throws *{EvalError}*
         * @param guild The guild property - (Mandatory)
         */
        this.resume = async (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _getQueue = (await queue.get(guild.id));
            if (!_getQueue || _getQueue === undefined || _getQueue === null)
                throw Error("The queue is empty.");
            this.isPaused = false;
            this.isPlaying = true;
            return this.player?.unpause();
        };
        /**
         * @default
         * @param guild The guild property - (Mandatory)
         * @param volumePercentage *The volume percentage. - (Mandatory)*
         * @throws *{EvalError}*
         */
        this.volume = async (guild, volumePercentage) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            if (typeof volumePercentage !== "number")
                throw Error(`The volume needs to be a number`);
            const _getQueue = (await queue.get(guild.id));
            if (!_getQueue || _getQueue === undefined || _getQueue === null)
                throw Error("The queue is empty.");
            if (volumePercentage > 100 || volumePercentage < 10)
                throw EvalError(`The volume cannot be lower than 10% and also cannot be higher than 100%`);
            const initialVolume = Math.pow(volumePercentage / 100, 1.660964);
            this.resource?.volume?.setVolume(initialVolume);
        };
        /**
         *@default
           @description *Clears the queue. (Doesn't destroys the actual queue. Only clears all of the tracks from the track list.)*
         * @param guild The guild property - (Mandatory)
         */
        this.clearQueue = async (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _getQueue = (await queue.get(guild.id));
            if (!_getQueue || _getQueue === undefined || _getQueue === null)
                throw Error("The queue is empty.");
            if (_getQueue?.tracks?.length < 0)
                return Error(`There is no tracks in the queue`);
            else
                return _getQueue.tracks?.splice(0, _getQueue?.tracks.length);
        };
        /**
         * @default
         * @description *Leaves the current voice channel that the bot is connected to.*
         *@param guild The guild property - (Mandatory)
         
         */
        this.leaveVoiceChannel = async (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const connection = await (0, voice_1.getVoiceConnection)(guild?.id);
            if (!connection)
                throw Error(`No voice connections found.`);
            else
                return connection.destroy();
        };
        /**
         * @default
         * @description *Connects to the voice channel. That you're connected to..*
         *@param guild The guild property - (Mandatory)
        @param voiceChannelId The id of the voice channel. - *(Mandatory)*
         
         */
        this.connect = async (guild, voiceChannelId) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const client = guild.members.me?.voice.channelId;
            if (client === voiceChannelId)
                throw EvalError(`Already connected to the voice channel`);
            const tConnection = await (0, voice_1.joinVoiceChannel)({
                adapterCreator: guild?.voiceAdapterCreator,
                channelId: `${voiceChannelId}`,
                guildId: guild.id,
                selfDeaf: false,
                selfMute: false,
            });
            this.emit("voiceConnected", tConnection);
        };
        /**
         *
         * @default
         *@param guild The guild property - (Mandatory)
         * @description *Adds a similar track to the current one that is playing.*
         * @param member The GuildMember property - *(Mandatory)*
         *
         */
        this.addRelatedTrack = async (guild, member) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const getQueue = (await queue.get(guild.id));
            if (!getQueue || getQueue === undefined || getQueue === null)
                throw Error("The queue is empty.");
            const currentTrack = await getQueue.tracks?.[0];
            const relatedTrack = await (0, findRelatedTrack_js_1.default)(currentTrack?.youtubeURL, member);
            getQueue.tracks?.push(relatedTrack);
            return relatedTrack;
        };
        /**
         * @default
         * @description *Get the current queue. *
         *@param guild The guild property - (Mandatory)
         
         */
        this.getQueue = async (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _getQueue = (await queue.get(guild?.id));
            if (!_getQueue || _getQueue === undefined || _getQueue === null)
                throw Error("The queue is empty.");
            return _getQueue;
        };
        /**
         *
         * @default
         * @description *Skips the current playing track.*
         *@param guild The guild property - (Mandatory)
         * @param type ChatInputCommandInteraction
         *
         */
        this.skip = async (guild, type) => {
            const _getQueue = (await queue.get(guild?.id));
            if (!_getQueue || _getQueue === undefined || _getQueue === null)
                throw Error("The queue is empty.");
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const lastSong = await _getQueue.tracks?.[0];
            _getQueue.previousSongs?.push(lastSong);
            _getQueue.tracks?.shift();
            this.isPaused = true;
            this.isPlaying = false;
            const _currentTrack = _getQueue.tracks?.[0];
            const _Stream = await play_dl_1.default.stream(_currentTrack?.youtubeURL);
            const resource = await (0, voice_1.createAudioResource)(_Stream.stream, {
                inlineVolume: true,
                inputType: _Stream.type,
            });
            const player = (0, voice_1.createAudioPlayer)({
                behaviors: {
                    noSubscriber: voice_1.NoSubscriberBehavior?.Play,
                },
            });
            player.play(resource);
            this.emit("trackNowPlaying", type, _getQueue.tracks?.[0]);
            this.connection?.subscribe(player);
            return _getQueue.tracks?.[0];
        };
        /**
         *
         * @description *Plays the last/previous track again.*
         * @param guild The guild property - (Mandatory)
         * @param type Message | ChatInputCommandInteraction - *(Mandatory)*
         *
         */
        this.playPrevious = async (guild, type) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _getQueue = queue?.get(guild?.id);
            if (!_getQueue || _getQueue === undefined || _getQueue === null)
                throw Error("The queue is empty.");
            const previousTrack = _getQueue.previousSongs[0];
            _getQueue.tracks?.push(previousTrack);
            const songs = _getQueue.tracks;
            songs?.unshift(songs[songs?.length - 1]);
            songs?.pop();
            const stream = await play_dl_1.default?.stream(songs?.[0].youtubeURL);
            const resource = await (0, voice_1.createAudioResource)(stream.stream, {
                inlineVolume: true,
                inputType: stream.type,
            });
            const player = (0, voice_1.createAudioPlayer)({
                behaviors: {
                    noSubscriber: voice_1.NoSubscriberBehavior?.Play,
                },
            });
            player.play(resource);
            this.emit("trackNowPlaying", type, songs?.[0]);
            this.connection?.subscribe(player);
            return songs?.[0];
        };
        /**
         *
         * @description *Stops the current playing track & will left the voice channel (Only if you specify the "leave value to true.")*
         * @param guild The guild property - (Mandatory)
         * @param leave *The boolean value of whether you want the bot to leave the voice channel or not.*
         *
         */
        this.stop = (guild, leave) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            if (typeof leave !== "boolean")
                throw Error("The leave property needs to be a boolean.");
            const _q = queue.get(guild.id);
            if (!_q || _q === undefined || _q === null)
                throw Error("The queue is empty.");
            queue?.delete(guild.id);
            this.player?.stop(true);
            const connection = (0, voice_1.getVoiceConnection)(guild?.id);
            if (!connection)
                return;
            else
                leave === true ? connection.destroy() : null;
        };
        /**
         *
         * @default
         * @description *Shuffles the current queue.*
         * @param guild The guild property - (Mandatory)
         *
         */
        this.shuffle = (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _q = queue.get(guild.id);
            if (!_q || _q === undefined || _q === null)
                throw Error("The queue is empty.");
            if (_q.tracks?.length < 1)
                throw Error(`Queue doesn't have enough songs to be shuffled`);
            const shuffledQueue = (0, suffixQueue_1.default)(_q?.tracks);
            _q.tracks?.splice(0, _q.tracks.length);
            shuffledQueue.map((track) => {
                return _q.tracks?.push(track);
            });
            return shuffledQueue;
        };
        /**
         *
         * @default
         * @description *Shows the current track information.*
          @param guild The guild property - (Mandatory)
         *
         */
        this.currentTrackInformation = async (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _queue = queue.get(guild?.id);
            if (!_queue || _queue === undefined || _queue === null)
                throw Error("The queue is empty.");
            const currentTrack = _queue.tracks?.[0];
            const relatedTrack = await await (0, relatedTrack_1.relatedTrackFinder)(currentTrack?.youtubeURL);
            const playBackDuration = this.resource?.playbackDuration;
            let _current = ((playBackDuration % 60000) / 1000).toFixed(0);
            const trackInfo = {
                currentTime: `${_current}` || _current,
                durationSeconds: currentTrack?.durationSeconds,
                author: currentTrack?.author,
                spotifyDuration: currentTrack?.spotifyDuration,
                spotifyThumbnail: currentTrack?.spotifyThumbnail,
                spotifyTitle: currentTrack?.spotifyTitle,
                spotifyURL: currentTrack?.spotifyURL,
                trackAddedOn: currentTrack?.trackAddedOn,
                user: currentTrack?.user,
                youtubeDuration: currentTrack?.youtubeDuration,
                youtubeThumbnail: currentTrack?.youtubeThumbnail,
                youtubeTitle: currentTrack?.youtubeTitle,
                youtubeURL: currentTrack?.spotifyURL,
                relatedTrack: {
                    length_seconds: relatedTrack.length_seconds,
                    published: relatedTrack.published,
                    id: relatedTrack.id,
                    isLive: relatedTrack.isLive,
                    short_view_count_text: relatedTrack.short_view_count_text,
                    thumbnails: relatedTrack.thumbnails,
                    title: relatedTrack.title,
                },
            };
            return trackInfo;
        };
        /**
         * @default
         * @since Saturday, 10 December 2022
         * @description The function as of now currently only supports the platform YouTube & Spotify as their main source of fetching data. So aside from YouTube & Spotify no platforms will be supported.
         *
         */
        this.getPlaylist = async (guild, uri, member) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            if (!member)
                throw Error("You need to specify a GuildMember | User.");
            if (typeof member !== "object")
                throw EvalError(`The GuildMember | User property needs to be a object`);
            const res = await (0, playlists_1.default)(`${uri}`, member);
            return res;
        };
        /**
         *If you're wondering how you can use this function, and what is the exact use of this function is, then consider check the example below
        @example
        ```ts
        import { Client, ApplicationCommandOptionType } from "discord.js";
        import { Player } from "frix";
      
        //Initializing the player.
        const player = new Player(client)
      
      
        client.on("interactionCreate", async(interaction) => {
          if (!interaction.isChatInputCommand()) {
          return;
        }
        if(interaction.commandName === "playlist_song_add") {
          await interaction.deferReply();
          const uri = await interaction.options.getString("playlist");
          const response = await player.getPlaylist!(interaction.guild!, uri, interaction?.member!);
          await player.tracksAdd!(interaction?.guild!, response?.tracks!);
      
          interaction.followUp({
          content: `Added ${response?.list.name} to the current queue.`
          })
        }
      
        })
      
        client.on("ready", () => {
          
            await client.guilds.cache.get("Your guild id here.")?.commands.set(
              [{
              name: "playlist_song_add",
              description: "Adds some songs to the queue.",
              options: [{
              name: "playlist",
              description : "Specify the playlist uri.",
              type: ApplicationCommandOptionType.String,
              required: true
            }]
            )
          }
        ])
        
        return console.log("The client is now up and ready to go.")
        })
      
        client.login("Your Bot Token.")
        ```
        @description In order to add tracks to the queue, you have to specify a proper tracks array.
         
         */
        this.tracksAdd = async (guild, type, listOfTracks) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            if (!Array.isArray(listOfTracks))
                throw Error("The list of tracks needs to be an array.");
            const _queue = (await queue?.get(guild?.id));
            _queue.tracks?.push(...listOfTracks);
            this.emit("listsOfSongsAdded", type, _queue);
            return listOfTracks;
        };
        /**
         * @default
         * @description *Jump/Skips to a particular track in the queue.*
         * @param guild The guild property - (Mandatory)
         * @param type  The type Message/ChatInputCommandInteraction.
         * @param skipTo The track position to skip/jump on.
         *
         */
        this.skipTo = async (guild, type, skipTo) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            if (typeof skipTo !== "number")
                throw EvalError("The track to skip to needs to be a number");
            const _q = queue.get(guild.id);
            if (!_q || _q === undefined || _q === null)
                throw Error("The queue is empty.");
            if (skipTo > _q.tracks?.length)
                throw Error(`You only have ${_q?.tracks?.length} tracks in the queue. `);
            const _previousSongs = _q.tracks?.splice(0, skipTo);
            _q.previousSongs?.push(..._previousSongs);
            const _Stream = await play_dl_1.default.stream(_q.tracks?.[0]?.youtubeURL);
            const resource = await (0, voice_1.createAudioResource)(_Stream.stream, {
                inlineVolume: true,
                inputType: _Stream.type,
            });
            const player = (0, voice_1.createAudioPlayer)({
                behaviors: {
                    noSubscriber: voice_1.NoSubscriberBehavior?.Play,
                },
            });
            this.emit("trackEnd", type, _q);
            player.play(resource);
            this.emit("trackNowPlaying", type, _q.tracks?.[0]);
            this.connection?.subscribe(player);
            return _q.tracks?.[0];
        };
        /**
         * @default
         * @description *Toggles the autoplay mode.*
         * @param guild The guild property - (Mandatory).
         *
         */
        this.toggleAutoPlay = async (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _queue = queue?.get(guild.id);
            if (!_queue || _queue === undefined || _queue === null)
                return this.isAutoPlayEnabled === true
                    ? (this.isAutoPlayEnabled = false)
                    : (this.isAutoPlayEnabled = true);
        };
        /**
         *@default
         * @description *Fully destroys the queue.*
         * @param guild The guild property - (Mandatory).
         *
         */
        this.destroyQueue = (guild) => {
            if (!guild)
                throw EvalError(`Specify a guild property first.`);
            if (typeof guild !== "object")
                throw EvalError(`Specify a guild property first.`);
            const _queue = queue?.get(guild.id);
            if (!_queue || _queue === undefined || _queue === null)
                throw Error("The queue is empty.");
            if (!_queue)
                throw Error("No queue found.");
            else
                queue?.delete(guild.id);
        };
        if (!client)
            throw Error(`You need to specify a client.`);
    }
}
exports.Player = Player;
